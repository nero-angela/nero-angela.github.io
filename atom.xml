<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🐈 Nero&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nero.devstory.co.kr/"/>
  <updated>2019-12-25T13:00:47.631Z</updated>
  <id>https://nero.devstory.co.kr/</id>
  
  <author>
    <name>Nero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</title>
    <link href="https://nero.devstory.co.kr/2019/12/25/pj-too-real-01/"/>
    <id>https://nero.devstory.co.kr/2019/12/25/pj-too-real-01/</id>
    <published>2019-12-25T07:44:28.000Z</published>
    <updated>2019-12-25T13:00:47.631Z</updated>
    
    <content type="html"><![CDATA[<p>딥러닝을 이용하여 더욱 현실감 있는 AR 어플리케이션을 개발한 이야기를 공유합니다.<br><a id="more"></a></p><blockquote><p>목차</p></blockquote><ul><li>✔︎ 1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</li><li><a href="/2019/12/24/pj-too-real-02/">2부. 현실감 있는 iOS AR앱 만들기</a></li><li><a href="/2019/12/23/pj-too-real-03/">3부. Custom YOLO 모델 만들기</a></li><li><a href="/2019/12/22/pj-too-real-04/">4부. iOS에 YOLO 모델 탑재하기</a></li></ul><hr><h1 id="프로젝트-소개"><a href="#프로젝트-소개" class="headerlink" title="# 프로젝트 소개"></a># 프로젝트 소개</h1><p><strong>AR(Augmented Reality)</strong>을 이용한 다양한 어플리케이션들이 출시되고 있습니다. 그런데 AR 어플리케이션 속의 가상 오브젝트들은 여러가지 이유로 현실감이 많이 떨어져 서비스 몰입도를 낮추는 것 같습니다.<br><br></p><div class="nero-grid">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="부자가 되고 싶은 자 AR을 개발해라(..?)<br>출처 : <a href=http://www.etoland.co.kr/plugin/mobile/board.php?bo_table=etohumor01&wr_id=1589967>http://www.etoland.co.kr/</a>"><source src="/assets/videos/pj-too-real/ar-example.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">부자가 되고 싶은 자 AR을 개발해라(..?)<br>출처 : <a href="http://www.etoland.co.kr/plugin/mobile/board.php?bo_table=etohumor01&wr_id=1589967" rel="external nofollow noopener noreferrer" target="_blank">http://www.etoland.co.kr/</a></span></div></div></div><p>대부분의 AR 어플리케이션에서 사용되는 3D 모델들은 아래 Apple Sample Code인 <a href="https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction" target="_blank" rel="external nofollow noopener noreferrer">Placing Objects and Handling 3D Interaction</a>에 사용된 램프 모델과 같이 <u>고정된 그림자 이미지</u>를 가지고 있습니다. 이러한 고정된 그림자는 보통 어떠한 상황에서도 어색하지 않을 범용적인 형태의 그림자를 가지고 있지만, 상황에 따라 주변 물체와의 이질감을 유발하는 원인 중 하나입니다.</p><div class="figure " style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/69901403-6d826000-13c4-11ea-9282-4b58dac120ac.png" target="_blank" rel="external nofollow noopener noreferrer" title="Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href=https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction>Placing Objects and Handling 3D Interaction</a>" data-caption="Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href=https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction>Placing Objects and Handling 3D Interaction</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/69901403-6d826000-13c4-11ea-9282-4b58dac120ac.png" alt="Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href=https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction>Placing Objects and Handling 3D Interaction</a>"></a><span class="caption">Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href="https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction" rel="external nofollow noopener noreferrer" target="_blank">Placing Objects and Handling 3D Interaction</a></span></div><p>고정된 그림자 이미지가 아닌, 임의의 가상 조명을 생성하여 오브젝트에 그림자를 랜더링하는 몇몇 AR 어플리케이션들이 있지만, 가상 조명의 위치나 밝기가 현실에 존재하는 실제 조명과 달라 부조화스러운 그림자를 생성해 오히려 현실감을 떨어뜨렸습니다.</p><p>따라서 이번 프로젝트에서는 부조화스러운 그림자 문제를 현실 조명의 <strong>위치</strong>와 <strong>밝기</strong> 정보를 수집하여 해결해 보도록 하겠습니다.</p><blockquote><p>✔︎ 프로젝트 목표<br>현실의 조명의 위치와 밝기 정보가 반영된, 더욱 현실감 있는 AR 어플리케이션 만들어보자!</p></blockquote><!-- TODO :: before와 after 이미지 넣고 이걸 이렇게! 추가하기 --><hr><h1 id="프로젝트-결과물"><a href="#프로젝트-결과물" class="headerlink" title="# 프로젝트 결과물"></a># 프로젝트 결과물</h1><hr><h2 id="개발-환경"><a href="#개발-환경" class="headerlink" title="개발 환경"></a>개발 환경</h2><p>1인 개발로 총 3개월이 소요되었으며, 다음과 같은 언어와 프레임워크를 사용하여 개발하였습니다.</p><div class="figure " style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70038098-10bcba80-15fb-11ea-94d2-314f8d598601.png" target="_blank" rel="external nofollow noopener noreferrer" title="개발에 사용된 언어, 프레임워크 및 툴" data-caption="개발에 사용된 언어, 프레임워크 및 툴" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70038098-10bcba80-15fb-11ea-94d2-314f8d598601.png" alt="개발에 사용된 언어, 프레임워크 및 툴"></a><span class="caption">개발에 사용된 언어, 프레임워크 및 툴</span></div><blockquote><p>✔︎ 개발 환경</p></blockquote><ul><li>OS : macOS Mojave 10.14</li><li>IDE : XCode / Jupyter Notebook</li><li>Language : Swift / Python3</li><li>iOS : <a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="external nofollow noopener noreferrer">ARKit</a> / <a href="https://developer.apple.com/documentation/scenekit" target="_blank" rel="external nofollow noopener noreferrer">SceneKit</a> / <a href="https://developer.apple.com/documentation/vision" target="_blank" rel="external nofollow noopener noreferrer">Vision</a> / <a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="external nofollow noopener noreferrer">CoreML</a></li><li>Data Labeling : <a href="https://github.com/tzutalin/labelImg" target="_blank" rel="external nofollow noopener noreferrer">labelImg</a></li><li>Deep Learning : <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="external nofollow noopener noreferrer">YOLO</a> / <a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="external nofollow noopener noreferrer">keras-yolo3</a></li></ul><hr><h2 id="데모-영상"><a href="#데모-영상" class="headerlink" title="데모 영상"></a>데모 영상</h2><p>백문이 불여일견이니 먼저 완성된 iOS 어플리케이션 작동 영상을 보겠습니다.</p><iframe width="100%" height="500" src="https://www.youtube.com/embed/1RMhd_r3AuQ?cc_load_policy=1&mute=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><!-- iOS 앱은 [App Store](https://apps.apple.com/kr/app/tooreal/id1473239669)에 게시해 두었습니다. --><hr><h1 id="기능-소개"><a href="#기능-소개" class="headerlink" title="# 기능 소개"></a># 기능 소개</h1><p>전체적인 어플리케이션은 다음과 같이 여섯 단계로 서비스 로직이 진행됩니다.</p><blockquote><p>✔︎ ARKit &amp; SceneKit을 이용한 AR 개발</p></blockquote><ul><li>평면 탐지(Plane Detection)</li><li>설치가능한 가상 오브젝트 추천</li><li>가상 오브젝트 설치 및 인터랙션</li></ul><blockquote><p>✔︎ 딥러닝을 이용한 조명 인식</p></blockquote><ul><li>Google Vision API 방식</li><li>YOLO(real time object detection) 방식</li></ul><hr><h2 id="ARKit-amp-SceneKit을-이용한-AR-개발"><a href="#ARKit-amp-SceneKit을-이용한-AR-개발" class="headerlink" title="ARKit &amp; SceneKit을 이용한 AR 개발"></a>ARKit &amp; SceneKit을 이용한 AR 개발</h2><div class="nero-grid">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="1. 평면 탐지(Plane Detection)"><source src="/assets/videos/pj-too-real/01.plane_detection.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">1. 평면 탐지(Plane Detection)</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="2. 설치가능한 가상 오브젝트 추천"><source src="/assets/videos/pj-too-real/02.object_recommendation.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">2. 설치가능한 가상 오브젝트 추천</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="3. 가상 오브젝트 설치 및 인터랙션"><source src="/assets/videos/pj-too-real/03.install_object.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">3. 가상 오브젝트 설치 및 인터랙션</span></div></div></div><p>어플리케이션이 현실 공간을 인식하여 벽면이나 바닥을 인식합니다. 공간이 인식되면 현재 바라보고 있는 장소에 설치 가능한 가구를 목록을 보여주고, 원하는 가구를 선택하여 설치할 수 있습니다. 또한 설치된 가구를 원하는 장소로 이동하거나 회전하는 등의 기본적인 인터랙션이 가능합니다.</p><hr><h2 id="딥러닝을-이용한-조명-인식"><a href="#딥러닝을-이용한-조명-인식" class="headerlink" title="딥러닝을 이용한 조명 인식"></a>딥러닝을 이용한 조명 인식</h2><p>본 어플리케이션에서는 두 가지 조명 인식 방식을 구현하였습니다. 하나는 <a href="https://cloud.google.com/vision" target="_blank" rel="external nofollow noopener noreferrer">Google Vision API</a>를 이용한 방법이고, 다른 방법은 <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="external nofollow noopener noreferrer">YOLO</a>라는 딥러닝 모델을 이용한 방법으로 다음과 같은 특징을 가지고있습니다.</p><br><table><thead><tr><th>✔︎ Google Vision API 방식</th><th>✔︎ YOLO(real time object detection) 방식</th></tr></thead><tbody><tr><td>• 네트워크 통신 필요</td><td>• 네트워크 통신 불필요</td></tr><tr><td>• 실시간 조명 추적 불가능</td><td>• 실시간 조명 추적 가능</td></tr><tr><td>• 조명의 정확한 좌표를 얻을 수 없음</td><td>• 조명의 2차원 좌표 획득 가능</td></tr><tr><td>• 조명의 온오프 상태를 알 수 없음</td><td>• 조명의 온오프 상태 구분가능</td></tr><tr><td>• 범용적인 조명 인식이 가능</td><td>• 학습된 5개의 조명만 인식가능</td></tr></tbody></table><hr><h3 id="1-Google-Vision-API-방식"><a href="#1-Google-Vision-API-방식" class="headerlink" title="1. Google Vision API 방식"></a>1. Google Vision API 방식</h3><div class="nero-grid">  <div>    <div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="Google Vision API를 이용한 가상조명 설치"><source src="/assets/videos/pj-too-real/07.install_scnlight_by_google_vision_api.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">Google Vision API를 이용한 가상조명 설치</span></div>  </div></div><p><code>Google Vision API</code>를 이용한 방식은 사용자가 조명을 바라보고 인식 버튼을 누르면 이미지를 Google Vision API 서버로 전달하여 조명 존재여부를 요청하고, 이미지 중앙좌표의 3차원 좌표를 <a href="https://developer.apple.com/documentation/arkit/arframe/2875718-hittest" target="_blank" rel="external nofollow noopener noreferrer">hitTest</a> 메소드를 통하여 획득합니다. 그리고 <code>Google Vision API</code>에서 조명이 존재한다고 반환하는 경우, 앞서 얻은 3차원 좌표에 가상 조명을 설치하는 방식입니다.</p><p>이 방법의 경우 조명의 실제 3차원 좌표가 아닌 곳에 가상 조명이 설치된 가능성이 있고, 실시간으로 조명을 인식하는 것이 아니라 사용자가 인식하고자 하는 조명 개수만큼 인식 버튼을 눌러야한다는 단점이 있습니다. 그럼에도 불구하고 Google에서 학습한 방대한 모델을 이용하기 때문에 범용적인 조명을 인식할 수 있다는 장점을 가지고 있습니다.</p><hr><h3 id="2-YOLO-real-time-object-detection-방식"><a href="#2-YOLO-real-time-object-detection-방식" class="headerlink" title="2. YOLO(real time object detection) 방식"></a>2. YOLO(real time object detection) 방식</h3><div class="nero-grid">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="YOLO 조명 on 상태 인식"><source src="/assets/videos/pj-too-real/04.install_scnlight.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">YOLO 조명 on 상태 인식</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="YOLO 조명 off 상태 인식"><source src="/assets/videos/pj-too-real/05.remove_scnlight.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">YOLO 조명 off 상태 인식</span></div></div></div><p>이 방식은 Realtime Object Detection 모델 중 하나인 <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="external nofollow noopener noreferrer">YOLO</a> 모델을 이용한 방식입니다. <code>YOLO</code> 모델은, 해당 이미지 안에 존재하는 조명의 온오프 상태, 종류, 신뢰도(confidence) 그리고 바운딩 박스(2차원 박스의 대각선 두 점의 좌표)를 반환합니다. 매프레임마다 바운딩 박스 좌표를 <a href="https://developer.apple.com/documentation/arkit/arframe/2875718-hittest" target="_blank" rel="external nofollow noopener noreferrer">hitTest</a> 메소드에 입력하여 조명의 3차원 좌표를 계산하고, 조명의 상태에 따라 경우 해당 좌표에 가상 조명을 추가하거나 삭제합니다.</p><p>모바일에 탑재한 <code>YOLO</code> 딥러닝 모델을 이용하기 때문에 네트워크 통신이 필요하지 않으며, 실시간으로 조명의 상태 및 좌표를 인식할 수 있다는 장점을 가지고 있습니다. 하지만 학습된 조명만 인식이 가능하다는 단점을 가지고 있습니다.<br><br></p><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>현실 조명에 대한 정보가 가상 오브젝트에 반영되었으므로, 아래 영상과 같이 오브젝트의 그림자가 조명과의 상대적 위치에 따라 현실감 있게 랜더링 되는 것을 보실 수 있습니다.<br><br></p><div class="nero-grid">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="그림자가 조명을 중심으로 랜더링 됩니다."><source src="/assets/videos/pj-too-real/06.shadow_rendering_and_object_interaction.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">그림자가 조명을 중심으로 랜더링 됩니다.</span></div>  </div></div><p>그 뿐만 아니라 카메라를 통해 들어오는 밝기(lm)과 색 온도(Kelvin)를 매프레임마다 가상 조명에 실시간으로 반영해주고 있기 때문에 가상 오브젝트가 주변과 유사한 텍스쳐로 표현되어 더욱 현실감을 높여줍니다.<br><br></p><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70371587-496cd480-1918-11ea-839e-93f5f3402969.png" target="_blank" rel="external nofollow noopener noreferrer" title="에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)" data-caption="에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70371587-496cd480-1918-11ea-839e-93f5f3402969.png" style="width:500px;" alt="에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)"></a><span class="caption">에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)</span></div><p>현실 조명의 위치와 밝기 그리고 색 온도 정보를 그대로 가상 조명으로 재현하여 <u>더욱 현실감 있는 AR 어플리케이션 구현</u>이라는 목표를 달성할 수 있었습니다. 🎉</p><p>이상으로 전체적인 프로젝트에 대한 소개를 마치고 다음 2부에서는 iOS AR 어플리케이션 개발 방법에 대해 공유하겠습니다.</p><blockquote><p>목차</p></blockquote><ul><li>✔︎ 1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</li><li><a href="/2019/12/24/pj-too-real-02/">2부. 현실감 있는 iOS AR앱 만들기</a></li><li><a href="/2019/12/23/pj-too-real-03/">3부. Custom YOLO 모델 만들기</a></li><li><a href="/2019/12/22/pj-too-real-04/">4부. iOS에 YOLO 모델 탑재하기</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;딥러닝을 이용하여 더욱 현실감 있는 AR 어플리케이션을 개발한 이야기를 공유합니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Project" scheme="https://nero.devstory.co.kr/categories/Project/"/>
    
    
      <category term="Too Real" scheme="https://nero.devstory.co.kr/tags/Too-Real/"/>
    
  </entry>
  
  <entry>
    <title>2부. 현실감 있는 iOS AR앱 만들기</title>
    <link href="https://nero.devstory.co.kr/2019/12/24/pj-too-real-02/"/>
    <id>https://nero.devstory.co.kr/2019/12/24/pj-too-real-02/</id>
    <published>2019-12-24T07:44:28.000Z</published>
    <updated>2019-12-25T13:20:10.645Z</updated>
    
    <content type="html"><![CDATA[<p>1부에서 소개한 현실감 있는 iOS AR 어플리케이션 개발 내용을 공유합니다.<br><a id="more"></a></p><blockquote><p>목차</p></blockquote><ul><li><a href="/2019/12/25/pj-too-real-01/">1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</a></li><li>✔︎ 2부. 현실감 있는 iOS AR앱 만들기</li><li><a href="/2019/12/23/pj-too-real-03/">3부. Custom YOLO 모델 만들기</a></li><li><a href="/2019/12/22/pj-too-real-04/">4부. iOS에 YOLO 모델 탑재하기</a></li></ul><hr><h1 id="iOS-AR-어플리케이션-개발"><a href="#iOS-AR-어플리케이션-개발" class="headerlink" title="# iOS AR 어플리케이션 개발"></a># iOS AR 어플리케이션 개발</h1><blockquote><p>프로젝트에 사용된 어플리케이션은 Apple에서 제공하는 Sample Code인 <a href="https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction" target="_blank" rel="external nofollow noopener noreferrer">Placing Objects and Handling 3D Interaction</a>의 일부 코드를 이용하여 만들었습니다.</p></blockquote><p>iOS 어플리케이션은 <a href="https://developer.apple.com/kr/augmented-reality/arkit/" target="_blank" rel="external nofollow noopener noreferrer">ARKit</a>과 <a href="https://developer.apple.com/documentation/scenekit" target="_blank" rel="external nofollow noopener noreferrer">SceneKit</a>를 이용하여 구현하였습니다. 기본적인 AR 어플리케이션 개발 방법에 대한 글은 많기 때문에, 이번 프로젝트의 핵심 기능인 <u><strong>가상 오브젝트의 그림자 캐스팅 방법</strong></u>과 <u><strong>현실과 같은 가상 조명 구현하기</strong></u> 대해서만 설명하도록 하겠습니다.</p><blockquote><p>✔︎ 진행 순서</p></blockquote><ul><li>가상 오브젝트의 그림자 캐스팅 방법</li><li>현실과 같은 가상 조명 구현하기</li></ul><hr><h2 id="가상-오브젝트의-그림자-캐스팅-방법"><a href="#가상-오브젝트의-그림자-캐스팅-방법" class="headerlink" title="가상 오브젝트의 그림자 캐스팅 방법"></a>가상 오브젝트의 그림자 캐스팅 방법</h2><p>먼저 가상 오브젝트의 그림자가 랜더링 되기 위해선 <code>평면 탐지(Plane Detection)</code> 기술이 필요 합니다. <code>평면 탐지(Plane Detection)</code>는 ARKit의 World Tracking를 이용하면 손쉽게 구현 할 수 있습니다. 탐지하고자 하는 평면을 <a href="https://developer.apple.com/documentation/arkit/arworldtrackingconfiguration" target="_blank" rel="external nofollow noopener noreferrer">ARWorldTrackingConfiguration</a>의 <a href="https://developer.apple.com/documentation/arkit/arworldtrackingconfiguration/2923548-planedetection" target="_blank" rel="external nofollow noopener noreferrer">PlaneDetection</a> 옵션을 통해 설정할 수 있습니다.</p><figure class="highlight swift"><figcaption><span>바닥은 horizontal, 벽은 vertical 입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguration</span>()</span><br><span class="line">configuration.planeDetection = [.horizontal, .vertical]</span><br></pre></td></tr></table></figure><p>이후 후면 카메라를 사용하여 관찰하는 모든 Plane 정보를 <a href="https://developer.apple.com/documentation/arkit/arsessiondelegate" target="_blank" rel="external nofollow noopener noreferrer">ARSessionDelegate</a>의 <a href="https://developer.apple.com/documentation/arkit/arsessiondelegate/2865617-session" target="_blank" rel="external nofollow noopener noreferrer">session(_:didAdd:)</a> 함수에서 <a href="https://developer.apple.com/documentation/arkit/arplaneanchor" target="_blank" rel="external nofollow noopener noreferrer">ARPlainAnchor</a> 객체로 받을 수 있습니다. 이렇게 전달받은 정보를 이용하여 그림자를 랜더링할 투명한 <a href="https://developer.apple.com/documentation/scenekit/scnplane" target="_blank" rel="external nofollow noopener noreferrer">SCNPlane</a>을 설치합니다.</p><figure class="highlight swift"><figcaption><span>투명한 SCNPlane 설치</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">renderer</span><span class="params">(<span class="number">_</span> renderer: SCNSceneRenderer, didAdd node: SCNNode, <span class="keyword">for</span> anchor: ARAnchor)</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> planeAnchor = anchor <span class="keyword">as</span>? <span class="type">ARPlaneAnchor</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (planeAnchor.alignment == .vertical) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> width  = <span class="type">CGFloat</span>(planeAnchor.extent.x)</span><br><span class="line">  <span class="keyword">let</span> height = <span class="type">CGFloat</span>(planeAnchor.extent.z)</span><br><span class="line">  <span class="keyword">let</span> plane  = <span class="type">SCNPlane</span>(width: width, height: height)</span><br><span class="line">  <span class="keyword">let</span> planeNode = <span class="type">SCNNode</span>(geometry: plane)</span><br><span class="line">  plane.firstMaterial!.colorBufferWriteMask = [] <span class="comment">// transparent</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> x = <span class="type">CGFloat</span>(planeAnchor.center.x)</span><br><span class="line">  <span class="keyword">let</span> y = <span class="type">CGFloat</span>(planeAnchor.center.y)</span><br><span class="line">  <span class="keyword">let</span> z = <span class="type">CGFloat</span>(planeAnchor.center.z)</span><br><span class="line">  planeNode.position = <span class="type">SCNVector3</span>(x, y, z)</span><br><span class="line">  planeNode.eulerAngles.x = -.pi / <span class="number">2</span></span><br><span class="line">  node.addChildNode(planeNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그림자가 그려질 바닥이 완성 되었으니 다음으로 조명을 설치하도록 하겠습니다.</p><hr><h2 id="현실과-같은-가상-조명-구현하기"><a href="#현실과-같은-가상-조명-구현하기" class="headerlink" title="현실과 같은 가상 조명 구현하기"></a>현실과 같은 가상 조명 구현하기</h2><p>먼저 현실과 같은 가상 조명을 만들려면 현실 조명의 <strong>위치</strong>와 <strong>강도(intensity) 그리고 색 온도(color temperature)</strong>가 필요 합니다.</p><blockquote><p>✔︎ 현실과 같은 가상 조명 구현시 필요한 데이터</p></blockquote><ul><li>조명의 3차원 <strong>위치</strong></li><li>조명의 <strong>강도(intensity)와 색 온도(color temperature)</strong></li></ul><p>조명의 <strong>위치</strong>는 <code>Google Vision API</code>와 <code>YOLO 모델</code>을 이용하여 현실 조명의 위치 정보를 수집하였는데, 그 방법에 대해선 <a href="/2019/11/24/pj-too-real-01/#딥러닝을-이용한-조명-인식">1부의 딥러닝을 이용한 조명인식</a> 파트를 참고해주시기 바랍니다.</p><p>조명의 <strong>강도와 색 온도</strong>는 ARKit의 <a href="https://developer.apple.com/documentation/arkit/arlightestimate" target="_blank" rel="external nofollow noopener noreferrer">Light Estimation</a>를 이용하여 수집하였는데, <code>Light Estimation</code> 객체는 카메라를 통해 들어오는 빛의 <a href="https://developer.apple.com/documentation/arkit/arlightestimate/2878308-ambientintensity" target="_blank" rel="external nofollow noopener noreferrer">강도(intensity)</a>와 <a href="https://developer.apple.com/documentation/arkit/arlightestimate/2921629-ambientcolortemperature" target="_blank" rel="external nofollow noopener noreferrer">색 온도(color temperature)</a> 값을 가지고 있습니다.</p><p>이렇게 현실 조명의 3차원 위치와 강도 그리고 색 온도를 수집하였고, SceneKit의 <a href="https://developer.apple.com/documentation/scenekit/scnlight" target="_blank" rel="external nofollow noopener noreferrer">SCNLight</a>의 속성으로 넣어주어 현실과 같은 <strong>위치</strong>에 현실과 같은 <strong>강도와 색 온도</strong>를 가진 가상 조명을 구현할 수 있습니다. 또한 <code>Light Estimation</code>의 정보를 매 프레임마다 적용하여 현실 조명의 밝기에 따라서 가상 조명도 밝기 정보를 갱신할 수 있습니다.</p><p><code>SCNLight</code>의 경우 다음 네 가지 type을 지원하며, 이 중에서 그림자 캐스팅은 <a href="https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1523624-directional" target="_blank" rel="external nofollow noopener noreferrer">directional</a> 타입과 <a href="https://developer.apple.com/documentation/scenekit/scnlight/lighttype/1523568-spot" target="_blank" rel="external nofollow noopener noreferrer">spot</a> 타입만 지원되며 <a href="https://developer.apple.com/documentation/scenekit/scnlight/1523816-castsshadow" target="_blank" rel="external nofollow noopener noreferrer">castsShadow</a> 옵션을 <code>True</code>로 변경해야 그림자가 캐스팅됩니다.</p><div class="figure " style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70532176-dbcfdb00-1b99-11ea-8d2f-5c90df4001b2.png" target="_blank" rel="external nofollow noopener noreferrer" title="이번 프로젝트에서는 directional 타입을 사용하였습니다. <br>출처 - <a href=https://developer.apple.com/documentation/scenekit/scnlight/lighttype>https://developer.apple.com</a>" data-caption="이번 프로젝트에서는 directional 타입을 사용하였습니다. <br>출처 - <a href=https://developer.apple.com/documentation/scenekit/scnlight/lighttype>https://developer.apple.com</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70532176-dbcfdb00-1b99-11ea-8d2f-5c90df4001b2.png" alt="이번 프로젝트에서는 directional 타입을 사용하였습니다. <br>출처 - <a href=https://developer.apple.com/documentation/scenekit/scnlight/lighttype>https://developer.apple.com</a>"></a><span class="caption">이번 프로젝트에서는 directional 타입을 사용하였습니다. <br>출처 - <a href="https://developer.apple.com/documentation/scenekit/scnlight/lighttype" rel="external nofollow noopener noreferrer" target="_blank">https://developer.apple.com</a></span></div><p>위와 같은 구성으로 가상 조명을 설치하면 가상 오브젝트가 마치 현실 조명을 인식하여 그림자가 그려진 듯한 현실감을 줄 수 있습니다.</p><br><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70371587-496cd480-1918-11ea-839e-93f5f3402969.png" target="_blank" rel="external nofollow noopener noreferrer" title="현실 조명의 위치와 강도 그리고 색 온도가 반영되어, 더욱 현실감 있는 AR을 경험할 수 있습니다." data-caption="현실 조명의 위치와 강도 그리고 색 온도가 반영되어, 더욱 현실감 있는 AR을 경험할 수 있습니다." data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70371587-496cd480-1918-11ea-839e-93f5f3402969.png" style="width:500px;" alt="현실 조명의 위치와 강도 그리고 색 온도가 반영되어, 더욱 현실감 있는 AR을 경험할 수 있습니다."></a><span class="caption">현실 조명의 위치와 강도 그리고 색 온도가 반영되어, 더욱 현실감 있는 AR을 경험할 수 있습니다.</span></div><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>이상으로 현실감있는 iOS AR앱 만들기에 대한 내용을 마치고 다음 3부에서는 조명의 위치를 실시간으로 탐지하는 <strong>YOLO</strong> 모델을 만드는 방법에 대해 공유하도록 하겠습니다.</p><blockquote><p>목차</p></blockquote><ul><li><a href="/2019/12/25/pj-too-real-01/">1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</a></li><li>✔︎ 2부. 현실감 있는 iOS AR앱 만들기</li><li><a href="/2019/12/23/pj-too-real-03/">3부. Custom YOLO 모델 만들기</a></li><li><a href="/2019/12/22/pj-too-real-04/">4부. iOS에 YOLO 모델 탑재하기</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1부에서 소개한 현실감 있는 iOS AR 어플리케이션 개발 내용을 공유합니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Project" scheme="https://nero.devstory.co.kr/categories/Project/"/>
    
    
      <category term="Too Real" scheme="https://nero.devstory.co.kr/tags/Too-Real/"/>
    
  </entry>
  
  <entry>
    <title>3부. Custom YOLO 모델 만들기</title>
    <link href="https://nero.devstory.co.kr/2019/12/23/pj-too-real-03/"/>
    <id>https://nero.devstory.co.kr/2019/12/23/pj-too-real-03/</id>
    <published>2019-12-23T07:44:28.000Z</published>
    <updated>2019-12-25T13:20:34.752Z</updated>
    
    <content type="html"><![CDATA[<p>실시간 객체 탐지 모델인 YOLO 모델을 학습하는 방법에 대해 공유합니다.<br><a id="more"></a></p><blockquote><p>목차</p></blockquote><ul><li><a href="/2019/12/25/pj-too-real-01/">1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</a></li><li><a href="/2019/12/24/pj-too-real-02/">2부. 현실감 있는 iOS AR앱 만들기</a></li><li>✔︎ 3부. Custom YOLO 모델 만들기</li><li><a href="/2019/12/22/pj-too-real-04/">4부. iOS에 YOLO 모델 탑재하기</a></li></ul><hr><h1 id="What-is-the-YOLO"><a href="#What-is-the-YOLO" class="headerlink" title="# What is the YOLO?"></a># What is the YOLO?</h1><p>시작하기에 앞서 YOLO에 대한 간단한 설명과 어떻게 Training 방법에 대해 알아보도록 하겠습니다.</p><blockquote><p>✔︎ 진행 순서</p></blockquote><ul><li>YOLO Architecture &amp; Output</li><li>Object Detection Data 준비</li><li>Transfer Learning</li></ul><blockquote><p>본 포스팅은 YOLO 모델 활용에 대한 글이므로, YOLO에 대한 자세한 설명은 다른 글을 참고하시기 바랍니다.</p><ul><li>영문 : <a href="https://www.cyberailab.com/home/a-closer-look-at-yolov3" target="_blank" rel="external nofollow noopener noreferrer">Closer Look at YOLOv3</a></li><li>한글 : <a href="https://curt-park.github.io/2017-03-26/yolo/" target="_blank" rel="external nofollow noopener noreferrer">[분석] YOLO</a></li></ul></blockquote><hr><h2 id="YOLO-Architecture"><a href="#YOLO-Architecture" class="headerlink" title="YOLO Architecture"></a>YOLO Architecture</h2><p><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="external nofollow noopener noreferrer">YOLO (You Only Look Once)</a>는 학습한 물체의 종류와 위치를 실시간으로 파악 할 수 있는 Real-Time Object Detection 모델로 다음과 같은 아키텍쳐로 구성되어 있습니다.<br><br></p><div class="figure " style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70716343-8e857200-1d2f-11ea-8e60-9c75f24ca9ce.png" target="_blank" rel="external nofollow noopener noreferrer" title="YOLO v3 Architecture<br>출처 - <a href=https://www.cyberailab.com/home/a-closer-look-at-yolov3>https://www.cyberailab.com</a>" data-caption="YOLO v3 Architecture<br>출처 - <a href=https://www.cyberailab.com/home/a-closer-look-at-yolov3>https://www.cyberailab.com</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70716343-8e857200-1d2f-11ea-8e60-9c75f24ca9ce.png" alt="YOLO v3 Architecture<br>출처 - <a href=https://www.cyberailab.com/home/a-closer-look-at-yolov3>https://www.cyberailab.com</a>"></a><span class="caption">YOLO v3 Architecture<br>출처 - <a href="https://www.cyberailab.com/home/a-closer-look-at-yolov3" rel="external nofollow noopener noreferrer" target="_blank">https://www.cyberailab.com</a></span></div><hr><h2 id="YOLO-Output"><a href="#YOLO-Output" class="headerlink" title="YOLO Output"></a>YOLO Output</h2><p>YOLO 모델의 output은 <code>N x N x (C + 5) x B)</code> 형태의 텐서(tensor)를 반환하며, 이 정보를 이용하여 이미지 상에 존재하는 물체의 종류와 2D 좌표를 획득할 수 있습니다.</p><blockquote><p>N x N x (C + 5) x B)</p></blockquote><ul><li>N x N : Grid</li><li>C : 학습한 Object 수(Classes)</li><li>5 : 탐지한 Object의 Bounding Box 정보(x, y, w, h, confidence)</li><li>B : Grid cell당 박스 수</li></ul><br><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70857358-09b57680-1f30-11ea-961a-0f9a401bc788.png" target="_blank" rel="external nofollow noopener noreferrer" title="YOLO output<br>출처 - <a href=https://www.cyberailab.com/home/a-closer-look-at-yolov3>https://www.cyberailab.com</a>" data-caption="YOLO output<br>출처 - <a href=https://www.cyberailab.com/home/a-closer-look-at-yolov3>https://www.cyberailab.com</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70857358-09b57680-1f30-11ea-961a-0f9a401bc788.png" alt="YOLO output<br>출처 - <a href=https://www.cyberailab.com/home/a-closer-look-at-yolov3>https://www.cyberailab.com</a>"></a><span class="caption">YOLO output<br>출처 - <a href="https://www.cyberailab.com/home/a-closer-look-at-yolov3" rel="external nofollow noopener noreferrer" target="_blank">https://www.cyberailab.com</a></span></div><p>다음으로 YOLO 모델을 학습을 위한 데이터 준비 방법을 알아보도록 하겠습니다.</p><hr><h1 id="학습-데이터-준비"><a href="#학습-데이터-준비" class="headerlink" title="# 학습 데이터 준비"></a># 학습 데이터 준비</h1><p>Object Detection 모델을 만들기 위해서는 오브젝트가 담긴 <strong>이미지</strong>와 이미지 상의 오브젝트의 위치와 종류를 나타내는 <strong>라벨</strong>이 필요합니다. 이번 프로젝트에서는 다음과 같은 순서로 데이터를 준비하였습니다.</p><blockquote><p>✔︎ 데이터 준비 순서</p></blockquote><ul><li>Image Gathering</li><li>Image Labeling</li><li>Image Resizing</li><li>Image Generating</li></ul><hr><h2 id="Image-Gathering"><a href="#Image-Gathering" class="headerlink" title="Image Gathering"></a>Image Gathering</h2><p>이번 프로젝트에서는 램프, 전구, 형광등 총 3개의 물체를 학습하였고 이를 위해 다음과 같은 이미지를 수집하였습니다. 램프와 전구의 경우 <u>ON/OFF 상태를 구분</u>할 수 있도록 다른 클래스로 분리하였기 때문에 총 클래스 수는 5개입니다.</p><div class="figure " style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70859476-81e36280-1f57-11ea-976b-697018feb25d.png" target="_blank" rel="external nofollow noopener noreferrer" title="조명 인식 모델을 만들기 위해 사용된 이미지" data-caption="조명 인식 모델을 만들기 위해 사용된 이미지" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70859476-81e36280-1f57-11ea-976b-697018feb25d.png" alt="조명 인식 모델을 만들기 위해 사용된 이미지"></a><span class="caption">조명 인식 모델을 만들기 위해 사용된 이미지</span></div><p>동영상으로 해당 오브젝트들을 촬영한 뒤 각 프레임들을 이미지로 변환하는 방법으로 총 5천장의 이미지를 수집하였습니다.</p><figure class="highlight python"><figcaption><span>OpenCV를 이용한 video to image</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(videoFiles)):</span><br><span class="line">    cam = cv2.VideoCapture(videoFile)</span><br><span class="line">    currentFrame = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        ret, frame = cam.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            cv2.imwrite(currentFrame + <span class="string">'.jpg'</span>, frame)</span><br><span class="line">            currentFrame += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cam.release()</span><br></pre></td></tr></table></figure><hr><h2 id="Image-Labeling"><a href="#Image-Labeling" class="headerlink" title="Image Labeling"></a>Image Labeling</h2><p>Object Detection 모델을 만들기 위해서는 학습하고자 하는 물체가 담긴 이미지와 해당 물체의 종류 그리고 위치 정보가 기록된 <strong>label</strong>이 필요합니다. <strong>label</strong>의 경우 직접 수작업으로 데이터를 생성해야 하는데, 작업을 편하게 하기 위해 <a href="https://github.com/tzutalin/labelImg" target="_blank" rel="external nofollow noopener noreferrer">labelImg</a>라는 오픈소스 툴을 이용하였습니다.</p><figure class="highlight xml"><figcaption><span>labelImg는 이미지 상의 오브젝트의 위치와 종류를 xml 형태로 반환합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">folder</span>&gt;</span>lamp_on<span class="tag">&lt;/<span class="name">folder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filename</span>&gt;</span>0.jpg<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/lamp_on/0.jpg<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">database</span>&gt;</span>Unknown<span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">width</span>&gt;</span>1920<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">height</span>&gt;</span>1080<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depth</span>&gt;</span>3<span class="tag">&lt;/<span class="name">depth</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">segmented</span>&gt;</span>0<span class="tag">&lt;/<span class="name">segmented</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>lamp_on<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>Unspecified<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">truncated</span>&gt;</span>0<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmin</span>&gt;</span>704<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymin</span>&gt;</span>384<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmax</span>&gt;</span>970<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymax</span>&gt;</span>546<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Image-Resizing"><a href="#Image-Resizing" class="headerlink" title="Image Resizing"></a>Image Resizing</h2><p>수집한 이미지의 원본은 <code>1920 x 1080</code>로 학습 시간이 많이 소요되기 때문에, <a href="https://pillow.readthedocs.io/en/stable/" target="_blank" rel="external nofollow noopener noreferrer">Pillow</a> 라이브러리를 이용하여 이미지의 크기를 10분의 1 크기인 <code>192 x 108</code>로 줄였습니다.</p><figure class="highlight python"><figcaption><span>image resizing</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">for</span> image_file <span class="keyword">in</span> images:</span><br><span class="line">  image = Image.open(image_file)</span><br><span class="line">  resize_image = image.resize((<span class="number">192</span>, <span class="number">108</span>))</span><br><span class="line">  resize_image.save(new_path)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>label resizing</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeLabel</span><span class="params">(xmlPath, newXmlPath, imgPath, boxes)</span>:</span></span><br><span class="line">    tree = elemTree.parse(xmlPath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># path 변경</span></span><br><span class="line">    path = tree.find(<span class="string">'./path'</span>)</span><br><span class="line">    path.text = imgPath[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bounding box 변경</span></span><br><span class="line">    objects = tree.findall(<span class="string">'./object'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, object_ <span class="keyword">in</span> enumerate(objects):</span><br><span class="line">        bndbox = object_.find(<span class="string">'./bndbox'</span>)</span><br><span class="line">        bndbox.find(<span class="string">'./xmin'</span>).text = str(boxes[i][<span class="number">0</span>])</span><br><span class="line">        bndbox.find(<span class="string">'./ymin'</span>).text = str(boxes[i][<span class="number">1</span>])</span><br><span class="line">        bndbox.find(<span class="string">'./xmax'</span>).text = str(boxes[i][<span class="number">2</span>])</span><br><span class="line">        bndbox.find(<span class="string">'./ymax'</span>).text = str(boxes[i][<span class="number">3</span>])</span><br><span class="line">    tree.write(newXmlPath, encoding=<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="Image-Generating"><a href="#Image-Generating" class="headerlink" title="Image Generating"></a>Image Generating</h2><p>양질의 데이터가 많을수록 모델의 성능은 좋아지지만, 너무 많은 데이터는 직접 라벨링을 하기가 힘들기 때문에 라벨링을 완료한 5천장의 이미지를 이용하여 추가 이미지를 생성하였습니다. 이미지를 생성하는 다양한 방법들이 있지만, <code>rotation</code>의 경우 Bounding Box의 표기법의 한계로 인해 오차가 커지기 때문에, <code>horizontal flip</code>을 이용한 방법으로 이미지를 1만장으로 늘렸습니다.</p><figure class="highlight python"><figcaption><span>horizontal flip</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomHorizontalFlip</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">        self.p = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, img, bboxes)</span>:</span></span><br><span class="line">        img_center = np.array(img.shape[:<span class="number">2</span>])[::<span class="number">-1</span>]/<span class="number">2</span></span><br><span class="line">        img_center = img_center.astype(int)</span><br><span class="line">        img_center = np.hstack((img_center, img_center))</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt; self.p:</span><br><span class="line">            img = img[:, ::<span class="number">-1</span>, :]</span><br><span class="line">            bboxes[:, [<span class="number">0</span>, <span class="number">2</span>]] += <span class="number">2</span>*(img_center[[<span class="number">0</span>, <span class="number">2</span>]] - bboxes[:, [<span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">            box_w = abs(bboxes[:, <span class="number">0</span>] - bboxes[:, <span class="number">2</span>])</span><br><span class="line">            bboxes[:, <span class="number">0</span>] -= box_w</span><br><span class="line">            bboxes[:, <span class="number">2</span>] += box_w</span><br><span class="line">        <span class="keyword">return</span> img, bboxes</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>image와 함께 label도 generating 하고있다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> imgFile <span class="keyword">in</span> imgFiles:</span><br><span class="line">    fileName = imgFile.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">    label = <span class="string">f'<span class="subst">&#123;labelPath&#125;</span><span class="subst">&#123;fileName&#125;</span>.xml'</span></span><br><span class="line">    w, h = getSizeFromXML(label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># opencv loads images in bgr. the [:,:,::-1] does bgr -&gt; rgb</span></span><br><span class="line">    image = cv2.imread(imgPath + imgFile)[:,:,::<span class="number">-1</span>]</span><br><span class="line">    bboxes = getRectFromXML(classes, label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HorizontalFlip image</span></span><br><span class="line">    image, bboxes = RandomHorizontalFlip(<span class="number">1</span>)(image.copy(), bboxes.copy())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save image</span></span><br><span class="line">    image = Image.fromarray(image, <span class="string">'RGB'</span>)</span><br><span class="line">    newImgPath = <span class="string">f'./data/light/image/train/<span class="subst">&#123;className&#125;</span>/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(newImgPath):</span><br><span class="line">        os.makedirs(newImgPath)</span><br><span class="line">    image.save(newImgPath + imgFile)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save label</span></span><br><span class="line">    newXmlPath = <span class="string">f'./data/light/label/train/<span class="subst">&#123;className&#125;</span>/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(newXmlPath):</span><br><span class="line">        os.makedirs(newXmlPath)</span><br><span class="line">    newXmlPath = newXmlPath + fileName + <span class="string">'.xml'</span></span><br><span class="line">    changeLabel(label, newXmlPath, newImgPath, bboxes)</span><br></pre></td></tr></table></figure><p>이렇게 라벨링된 이미지 준비를 끝마쳤습니다. 다음으로 데이터를 이용하여 YOLO 모델을 학습시키는 방법에 대해 설명하도록 하겠습니다.</p><hr><h1 id="YOLO-Training"><a href="#YOLO-Training" class="headerlink" title="# YOLO Training"></a># YOLO Training</h1><p><a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="external nofollow noopener noreferrer">Keras-yolo3</a> 라이브러리를 이용하여 YOLO 모델을 학습시켰습니다.</p><p>✔︎ 진행순서</p><ul><li>Convert Darknet Model To Keras Model</li><li>Convert Annotation</li><li>Training</li></ul><hr><h2 id="Convert-Darknet-Model-To-Keras-Model"><a href="#Convert-Darknet-Model-To-Keras-Model" class="headerlink" title="Convert Darknet Model To Keras Model"></a>Convert Darknet Model To Keras Model</h2><p>YOLO v3 모델의 경우 모바일 기기에 올리기에는 너무 무거움으로 경량화 버전인 Tiny YOLO v3 모델을 이용하였고, 기존에 학습된 weight를 그대로 사용할 수 있는 전이학습(transfer learning)을 이용하여 학습을 진행하였습니다.</p><figure class="highlight shell"><figcaption><span>tiny yolov3 pretrained weights 다운로드</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/yolov3-tiny.weights</span><br></pre></td></tr></table></figure><p>위 명령어를 실행하면 <code>yolov3-tiny.weights</code>라는 35.4MB의 weights를 다운받을 수 있습니다. YOLO3 자체는 C/C++로 구현된 DarkNet 프레임워크로 구현되어 있습니다. 이를 Keras에서 사용할 수 있는 <code>.h5</code> 포멧으로 변환해야합니다. 변환 방법은 <a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="external nofollow noopener noreferrer">Keras-yolo3</a>의 <code>convert.py</code> 파일을 이용합니다.</p><figure class="highlight python"><figcaption><span>Convert darknet model to keras model</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python convert.py yolov3-tiny.cfg yolov3-tiny.weights model_data/yolo_tiny.h5</span><br></pre></td></tr></table></figure><blockquote><p>✔︎ Convert darknet model to keras model</p></blockquote><ul><li>convert.py : 변환명령 수행 파일</li><li>yolov3.cfg : Darknet에서 사용하는 모델 구조 정의 파일</li><li>yolov3.weight : Darknet으로 학습된 모델 파일</li></ul><p>완료가 되면 <code>.h5</code>형태로 weights 파일이 변환됩니다. 다음으로 변환된 모델이 잘 작동하는지 테스트를 위해 아래 샘플 이미지를 이용해보도록 하겠습니다.</p><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70893892-5338bb00-202f-11ea-8c72-e7d48f83f2a9.png" target="_blank" rel="external nofollow noopener noreferrer" title="sample image : dog.jpg<br>출처 : <a href=https://github.com/pjreddie/darknet>darknet</a>" data-caption="sample image : dog.jpg<br>출처 : <a href=https://github.com/pjreddie/darknet>darknet</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70893892-5338bb00-202f-11ea-8c72-e7d48f83f2a9.png" style="width:500px;" alt="sample image : dog.jpg<br>출처 : <a href=https://github.com/pjreddie/darknet>darknet</a>"></a><span class="caption">sample image : dog.jpg<br>출처 : <a href="https://github.com/pjreddie/darknet" rel="external nofollow noopener noreferrer" target="_blank">darknet</a></span></div><figure class="highlight python"><figcaption><span>tiny YOLO v3 converted model test</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> yolo <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objectDetection</span><span class="params">(file, model_path, class_path)</span>:</span></span><br><span class="line">    yolo = YOLO(model_path=model_path, classes_path=class_path, anchors_path=<span class="string">"model_data/tiny_yolo_anchors.txt"</span>)</span><br><span class="line">    image = Image.open(file)</span><br><span class="line">    result_image = yolo.detect_image(image)</span><br><span class="line">    display(result_image)</span><br><span class="line"></span><br><span class="line">objectDetection(<span class="string">'dog.jpg'</span>, <span class="string">'model_data/yolo_tiny.h5'</span>, <span class="string">'model_data/coco_classes.txt'</span>)</span><br></pre></td></tr></table></figure><p>YOLO 모델이 적절한 bounding box와 confidence 그리고 class를 반환하는 것을 보니 변환에 성공한 것 같습니다.</p><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70894441-5aac9400-2030-11ea-8f65-adeb4dd2f779.png" target="_blank" rel="external nofollow noopener noreferrer" title="자전거, 개, 자동차를 탐지한 YOLO model<br>출처 : <a href=https://github.com/pjreddie/darknet>darknet</a>" data-caption="자전거, 개, 자동차를 탐지한 YOLO model<br>출처 : <a href=https://github.com/pjreddie/darknet>darknet</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70894441-5aac9400-2030-11ea-8f65-adeb4dd2f779.png" style="width:500px;" alt="자전거, 개, 자동차를 탐지한 YOLO model<br>출처 : <a href=https://github.com/pjreddie/darknet>darknet</a>"></a><span class="caption">자전거, 개, 자동차를 탐지한 YOLO model<br>출처 : <a href="https://github.com/pjreddie/darknet" rel="external nofollow noopener noreferrer" target="_blank">darknet</a></span></div><hr><h2 id="Convert-Annotation"><a href="#Convert-Annotation" class="headerlink" title="Convert Annotation"></a>Convert Annotation</h2><p><a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="external nofollow noopener noreferrer">Keras-yolo3</a>에서 데이터를 학습하기 위해선 위에서 labeling한 데이터를 아래와 같은 형태로 변환해야합니다. <code>voc_annotation.py</code> 파일을 참고하여 아래와 같은 형태로 변환하시면 됩니다.</p><blockquote><p>✔︎ Annotation Format</p></blockquote><ul><li>Row format: image_file_path box1 box2 … boxN</li><li>Box format: x_min,y_min,x_max,y_max,class_id (no space)</li></ul><figure class="highlight python"><figcaption><span>Annotation example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path/to/img1.jpg <span class="number">50</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">0</span> <span class="number">30</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">120</span>,<span class="number">3</span></span><br><span class="line">path/to/img2.jpg <span class="number">120</span>,<span class="number">300</span>,<span class="number">250</span>,<span class="number">600</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>Convert annotation</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_annotation</span><span class="params">(annotation_voc, train_all_file)</span>:</span></span><br><span class="line">    tree = ET.parse(annotation_voc)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.iter(<span class="string">'object'</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">'difficult'</span>).text</span><br><span class="line">        cls = obj.find(<span class="string">'name'</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> int(difficult)==<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)</span><br><span class="line">        xmlbox = obj.find(<span class="string">'bndbox'</span>)</span><br><span class="line">        b = (int(xmlbox.find(<span class="string">'xmin'</span>).text), int(xmlbox.find(<span class="string">'ymin'</span>).text), int(xmlbox.find(<span class="string">'xmax'</span>).text), int(xmlbox.find(<span class="string">'ymax'</span>).text))</span><br><span class="line">        train_all_file.write(<span class="string">" "</span> + <span class="string">","</span>.join([str(a) <span class="keyword">for</span> a <span class="keyword">in</span> b]) + <span class="string">','</span> + str(cls_id))</span><br><span class="line"></span><br><span class="line">train_all_file = open(<span class="string">'./data/light/train_all.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get annotations_voc list</span></span><br><span class="line"><span class="keyword">for</span> className <span class="keyword">in</span> classes:</span><br><span class="line">    annotations_voc = glob.glob(<span class="string">f'./data/light/label/train/<span class="subst">&#123;className&#125;</span>/*.xml'</span>)</span><br><span class="line">    <span class="keyword">for</span> annotation_voc <span class="keyword">in</span> annotations_voc:</span><br><span class="line">        image_id = annotation_voc.split(<span class="string">'/'</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]+<span class="string">'.JPG'</span></span><br><span class="line">        train_all_file.write(<span class="string">f'./data/light/image/train/<span class="subst">&#123;className&#125;</span>/<span class="subst">&#123;image_id&#125;</span>'</span>)</span><br><span class="line">        convert_annotation(annotation_voc, train_all_file)</span><br><span class="line">        train_all_file.write(<span class="string">'\n'</span>)</span><br><span class="line">train_all_file.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>필자의 annotation 변환 결과</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./data/light/image/train/bulb_on/<span class="number">162.J</span>PG <span class="number">70</span>,<span class="number">0</span>,<span class="number">124</span>,<span class="number">52</span>,<span class="number">0</span></span><br><span class="line">./data/light/image/train/bulb_on/<span class="number">1390.J</span>PG <span class="number">70</span>,<span class="number">61</span>,<span class="number">117</span>,<span class="number">100</span>,<span class="number">0</span></span><br><span class="line">./data/light/image/train/bulb_on/<span class="number">604.J</span>PG <span class="number">78</span>,<span class="number">38</span>,<span class="number">93</span>,<span class="number">52</span>,<span class="number">0</span></span><br><span class="line">./data/light/image/train/bulb_on/<span class="number">88.J</span>PG <span class="number">72</span>,<span class="number">28</span>,<span class="number">139</span>,<span class="number">93</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h2><p>마지막으로 학습은 <code>train.py</code> 파일의 <code>_main()</code> 함수에 다음과 같은 변수가 있는데 이를 수정하여 실행하면 됩니다.</p><figure class="highlight python"><figcaption><span>train.py의 _main()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_main</span><span class="params">()</span>:</span></span><br><span class="line">  annotation_path = <span class="string">'data/light/train_all.txt'</span> <span class="comment"># 위 Convert Annotation의 결과 파일경로</span></span><br><span class="line">  log_dir = <span class="string">'logs/000/'</span> <span class="comment"># 학습 로그 저장경로</span></span><br><span class="line">  classes_path = <span class="string">'data/light/classes.txt'</span> <span class="comment"># 학습하는 클래스 목록</span></span><br><span class="line">  anchors_path = <span class="string">'model_data/yolo_tiny_anchors.txt'</span> <span class="comment"># tiny YOLO 모델의 anchors</span></span><br><span class="line">  transfer_learning_path = <span class="string">'model_data/yolo_tiny.h5'</span> <span class="comment"># Convert Darknet Model To Keras Model 결과 h5파일</span></span><br><span class="line">  <span class="comment"># ... 이하 생략</span></span><br></pre></td></tr></table></figure><p>위와같이 수정을 한 뒤 실행을 하면 기존 pretraining 된 tiny YOLO weights를 로드한 뒤, 전이학습(Transfer Learning)을 시작합니다. 총 100epoch을 batch size 32로 진행하는데, 50에폭까지는 전체 44개의 Layer 중 42개를 Freeze 한 뒤 학습이 진행되고, 이후에는 모든 레이어를 Unfreeze한 뒤 학습이 진행됩니다.</p><p>하지만 Keras의 <a href="https://keras.io/callbacks/#earlystopping" target="_blank" rel="external nofollow noopener noreferrer">EarlyStop</a>이 다음과 같은 조건으로 적용되어있어 전체 100epoch을 진행하기 전에 학습이 끝나기도 합니다.</p><figure class="highlight python"><figcaption><span>EarlyStopping</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EarlyStopping(monitor=<span class="string">'val_loss'</span>, min_delta=<span class="number">0</span>, patience=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>또한 최적의 모델을 선택하기 위해 <a href="https://keras.io/callbacks/#modelcheckpoint" target="_blank" rel="external nofollow noopener noreferrer">ModelCheckpoint</a> 함수가 validation error 를 모니터링하면서, 이전 epoch 에 비해 validation performance 가 좋은 경우, 무조건 이 때의 parameter들을 중간중간 저장되고 있어서 학습이 도중에 멈추더라도 중간 결과물을 보존할 수 있습니다.</p><p>모든 학습이 완료되었으니 모델을 테스트하도록 하겠습니다.</p><figure class="highlight python"><figcaption><span>Trained Model Test</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> yolo <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objectDetection</span><span class="params">(file, model_path, class_path)</span>:</span></span><br><span class="line">    yolo = YOLO(model_path=model_path, classes_path=class_path, anchors_path=<span class="string">'model_data/yolo_tiny_anchors.txt'</span>)</span><br><span class="line">    image = Image.open(file)</span><br><span class="line">    result_image = yolo.detect_image(image)</span><br><span class="line">    display(result_image)</span><br><span class="line"></span><br><span class="line">objectDetection(<span class="string">'data/light/test/562.jpg'</span>, <span class="string">'model_data/light_tiny_model.h5'</span>, <span class="string">'data/light/classes.txt'</span>)</span><br></pre></td></tr></table></figure><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70910091-509b8d00-2052-11ea-8305-d4e810eebcad.png" target="_blank" rel="external nofollow noopener noreferrer" title="전이학습이 완료된 tiny YOLO v3 output" data-caption="전이학습이 완료된 tiny YOLO v3 output" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70910091-509b8d00-2052-11ea-8305-d4e810eebcad.png" alt="전이학습이 완료된 tiny YOLO v3 output"></a><span class="caption">전이학습이 완료된 tiny YOLO v3 output</span></div><p>이미지에 담긴 조명의 정확한 Bounding Box와 신뢰도 그리고 종류를 잘 탐지하고 있습니다. 테스트까지 완료된 모델을 파일로 저장하기 위해 <a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="external nofollow noopener noreferrer">Keras-yolo3</a>의 <code>yolo.py</code> 파일에 학습된 모델을 반환하는 함수를 추가하였습니다.</p><figure class="highlight python"><figcaption><span>yolo.py 파일에 학습된 모델을 반환하는 함수를 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.yolo_model</span><br></pre></td></tr></table></figure><p>그리고 모델의 save함수를 이용하여 학습이 완료된 모델을 저장하였습니다.</p><figure class="highlight python"><figcaption><span>save keras h5 model</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = yolo.get_model()</span><br><span class="line">model.save(<span class="string">'model_data/light_tiny_model.h5'</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>다음 4부에서는 학습한 YOLO Model을 iOS 어플리케이션에 올리는 방법에 대해 설명하도록 하겠습니다.</p><blockquote><p>목차</p></blockquote><ul><li><a href="/2019/12/25/pj-too-real-01/">1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</a></li><li><a href="/2019/12/24/pj-too-real-02/">2부. 현실감 있는 iOS AR앱 만들기</a></li><li>✔︎ 3부. Custom YOLO 모델 만들기</li><li><a href="/2019/12/22/pj-too-real-04/">4부. iOS에 YOLO 모델 탑재하기</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;실시간 객체 탐지 모델인 YOLO 모델을 학습하는 방법에 대해 공유합니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Project" scheme="https://nero.devstory.co.kr/categories/Project/"/>
    
    
      <category term="Too Real" scheme="https://nero.devstory.co.kr/tags/Too-Real/"/>
    
  </entry>
  
  <entry>
    <title>4부. iOS에 YOLO 모델 탑재하기</title>
    <link href="https://nero.devstory.co.kr/2019/12/22/pj-too-real-04/"/>
    <id>https://nero.devstory.co.kr/2019/12/22/pj-too-real-04/</id>
    <published>2019-12-22T07:44:28.000Z</published>
    <updated>2019-12-25T13:20:26.615Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 어플리케이션에 YOLO 모델을 탑재하는 방법에 대해 공유합니다.<br><a id="more"></a></p><blockquote><p>목차</p></blockquote><ul><li><a href="/2019/12/25/pj-too-real-01/">1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</a></li><li><a href="/2019/12/24/pj-too-real-02/">2부. 현실감 있는 iOS AR앱 만들기</a></li><li><a href="/2019/12/23/pj-too-real-03/">3부. Custom YOLO 모델 만들기</a></li><li>✔︎ 4부. iOS에 YOLO 모델 탑재하기</li></ul><hr><h1 id="CoreML-이용방법"><a href="#CoreML-이용방법" class="headerlink" title="# CoreML 이용방법"></a># CoreML 이용방법</h1><p><a href="https://developer.apple.com/documentation/coreml" target="_blank" rel="external nofollow noopener noreferrer">CoreML</a>은 애플의 머신러닝 프레임워크로, iOS 어플리케이션에 손쉽게 머신러닝 모델을 올릴 수 있도록 도와줍니다.</p><blockquote><p>✔︎ 진행 순서</p></blockquote><ul><li>CoreML Tools를 이용하여 mlmodel 만들기</li><li>CoreML을 이용하여 iOS에 모델 올리기</li></ul><hr><h2 id="CoreML-Tools를-이용하여-mlmodel-만들기"><a href="#CoreML-Tools를-이용하여-mlmodel-만들기" class="headerlink" title="CoreML Tools를 이용하여 mlmodel 만들기"></a>CoreML Tools를 이용하여 mlmodel 만들기</h2><p>CoreML을 이용하여 모델을 올리기 위해선 먼저 모델을 <code>.mlmodel</code> 형태로 변환해야하는데, <a href="https://pypi.org/project/coremltools/" target="_blank" rel="external nofollow noopener noreferrer">CoreML Tools</a>를 이용하면 손쉽게 변환 할 수 있습니다. <code>CoreML Tools</code>는 Darknet 포멧을 지원하지 않기 때문에 앞서 Darknet 모델을 Keras 모델로 변환하여 학습을 진행하였습니다.</p><figure class="highlight python"><figcaption><span>CoreML Tools를 이용하여 keras 모델을 mlmodel로 변환</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> coremltools</span><br><span class="line">coreml_model = coremltools.converters.keras.convert(<span class="string">'model_data/light_tiny_model.h5'</span>,</span><br><span class="line">                                                    image_input_names=<span class="string">'image'</span>,</span><br><span class="line">                                                    input_names=<span class="string">'image'</span>,</span><br><span class="line">                                                    output_names=[<span class="string">'13'</span>],</span><br><span class="line">                                                    image_scale=<span class="number">1</span>/<span class="number">255.0</span>)</span><br><span class="line">coreml_model.output_description[<span class="string">'13'</span>] = <span class="string">'13 x 13 x 30'</span></span><br><span class="line">coreml_model.save(<span class="string">'model_data/light_tiny_model.mlmodel'</span>)</span><br></pre></td></tr></table></figure><p>3부에서 학습하여 만든 Tiny YOLO 모델은 이미지를 <code>13 x 13</code> Grid로 나누어 5개의 클래스에 대해 Grid 당 3개의 박스를 예측하기 때문에 <code>13 x 13 x 30</code>의 결과를 반환하기 때문에 위와같이 output을 설정해주었습니다.</p><blockquote><p>N x N x (C + 5) x B)</p></blockquote><ul><li>N x N : Grid</li><li>C : 학습한 Object 수(Classes)</li><li>5 : 탐지한 Object의 Bounding Box 정보(x, y, w, h, confidence)</li><li>B : Grid cell당 박스 수</li></ul><hr><h2 id="CoreML을-이용하여-iOS에-모델-올리기"><a href="#CoreML을-이용하여-iOS에-모델-올리기" class="headerlink" title="CoreML을 이용하여 iOS에 모델 올리기"></a>CoreML을 이용하여 iOS에 모델 올리기</h2><p><code>light_tiny_model.mlmodel</code> 모델을 iOS 프로젝트에 추가하면, 다음과 같이 사용할 수 있습니다.</p><figure class="highlight swift"><figcaption><span>Load mlmodel</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreML</span><br><span class="line"><span class="keyword">let</span> model = light_tiny_model()</span><br></pre></td></tr></table></figure><p>Model은 인자로 <code>416 x 416</code> size인 <a href="https://developer.apple.com/documentation/corevideo/cvpixelbuffer-q2e" target="_blank" rel="external nofollow noopener noreferrer">CVPixelBuffer</a>를 받는 prediction 함수를 가지고있습니다.</p><figure class="highlight swift"><figcaption><span>model prediction</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.prediction(image: <span class="type">CVPixelBuffer</span>)</span><br></pre></td></tr></table></figure><p>CVPixelBuffer는 ARSessionDeligate의 <a href="https://developer.apple.com/documentation/arkit/arsessiondelegate/2865611-session" target="_blank" rel="external nofollow noopener noreferrer">session(_:didUpdate:)</a> 함수의 <a href="https://developer.apple.com/documentation/arkit/arframe/2867984-capturedimage" target="_blank" rel="external nofollow noopener noreferrer">ARFrame.capturedImage</a>를 이용하여 실시간 CVPixelBuffer를 얻을 수 있습니다.</p><figure class="highlight swift"><figcaption><span>매프레임마다 호출되는 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: ARSession, didUpdate frame: ARFrame)</span></span> &#123;</span><br><span class="line">    model.prediction(image: frame.capturedImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Model-Input-Image-Preprocessing"><a href="#Model-Input-Image-Preprocessing" class="headerlink" title="# Model Input Image Preprocessing"></a># Model Input Image Preprocessing</h1><blockquote><p>프로젝트에 많은 참고가 된 <a href="https://github.com/hollance/YOLO-CoreML-MPSNNGraph/tree/master/TinyYOLO-CoreML" target="_blank" rel="external nofollow noopener noreferrer">TinyYOLO-CoreML</a>에서는 <code>ARSessionDelegate</code>가 아닌 <code>AVCaptureVideoDataOutputSampleBufferDelegate</code>를 이용하고 있습니다.</p></blockquote><p>동일한 아이폰에서 ARKit의 <a href="https://developer.apple.com/documentation/arkit/arsessiondelegate" target="_blank" rel="external nofollow noopener noreferrer">ARSessionDelegate</a>과 AVFoundation의 <a href="https://developer.apple.com/documentation/avfoundation/avcapturevideodataoutputsamplebufferdelegate" target="_blank" rel="external nofollow noopener noreferrer">AVCaptureVideoDataOutputSampleBufferDelegate</a>는 서로 다른 이미지를 반환합니다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVCaptureVideoDataOutputSampleBufferDelegate</span></span><br><span class="line"><span class="type">CVPixelBuffer</span> <span class="type">Height</span> : <span class="number">1280</span></span><br><span class="line"><span class="type">CVPixelBuffer</span> <span class="type">Width</span>  : <span class="number">720</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ARSessionDelegate</span></span><br><span class="line"><span class="type">CVPixelBuffer</span> <span class="type">Height</span> : <span class="number">1440</span></span><br><span class="line"><span class="type">CVPixelBuffer</span> <span class="type">Width</span>  : <span class="number">1920</span></span><br></pre></td></tr></table></figure><p>이번 프로젝트에서 사용하는 <code>ARSessionDelegate</code>는 왼쪽으로 회전된 이미지를 반환하므로 이미지를 <code>오른쪽으로 회전</code>시키고, Model의 input size인 <code>416 x 416으로 변환</code>하는 전처리가 필요합니다.</p><p>전처리 방법으로 <a href="https://developer.apple.com/documentation/coreimage" target="_blank" rel="external nofollow noopener noreferrer">Core Image</a>와 <a href="https://developer.apple.com/documentation/vision" target="_blank" rel="external nofollow noopener noreferrer">Vision</a> 두 프레임워크를 이용한 방법을 공유하겠습니다.</p><blockquote><p>✔︎ 진행 순서</p></blockquote><ul><li>Core Image Framework</li><li>Vision Framework</li></ul><blockquote><p>이번 글에서는 다루지 않았지만 성능 향상을 위해 이미지 전처리 부분을 <a href="https://developer.apple.com/documentation/dispatch/dispatchsemaphore" target="_blank" rel="external nofollow noopener noreferrer">DispatchSemaphore</a>와 <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue" target="_blank" rel="external nofollow noopener noreferrer">DispatchQueue</a> 등을 이용하여 병렬로 처리하였습니다. 관련 내용은 <a href="https://github.com/hollance/YOLO-CoreML-MPSNNGraph/tree/master/TinyYOLO-CoreML" target="_blank" rel="external nofollow noopener noreferrer">TinyYOLO-CoreML</a>를 참고해주세요.</p></blockquote><hr><h2 id="Core-Image-Framework"><a href="#Core-Image-Framework" class="headerlink" title="Core Image Framework"></a>Core Image Framework</h2><p><a href="https://developer.apple.com/documentation/coreimage" target="_blank" rel="external nofollow noopener noreferrer">Core Image</a>은 iOS에서 지원하는 이미지 분석 및 처리 프레임워크입니다. Core Image를 이용하여 CVPixelBuffer를 YOLO Model의 input에 적합하도록 변환해보도록 하겠습니다.</p><figure class="highlight swift"><figcaption><span>Core Image Framework를 이용한 전처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">ModelInputWidth</span> = <span class="number">416</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">ModelInputHeight</span> = <span class="number">416</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResizedPixelBufferByCoreImage</span><span class="params">(pixelBuffer: CVPixelBuffer)</span></span> -&gt; <span class="type">CVPixelBuffer</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> resizedPixelBuffer: <span class="type">CVPixelBuffer?</span></span><br><span class="line">  <span class="type">CVPixelBufferCreate</span>(<span class="literal">nil</span>, <span class="type">ModelInputWidth</span>, <span class="type">ModelInputHeight</span>, kCVPixelFormatType_32BGRA, <span class="literal">nil</span>, &amp;resizedPixelBuffer)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> ciImage = <span class="type">CIImage</span>(cvPixelBuffer: pixelBuffer)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Rotate</span></span><br><span class="line">  <span class="keyword">let</span> rotatedImage = ciImage.oriented(forExifOrientation: <span class="type">Int32</span>(<span class="type">CGImagePropertyOrientation</span>.<span class="keyword">right</span>.rawValue))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Scale to YOLO input size</span></span><br><span class="line">  <span class="keyword">let</span> sx = <span class="type">CGFloat</span>(<span class="type">ModelInputWidth</span>) / <span class="type">CGFloat</span>(<span class="type">CVPixelBufferGetHeight</span>(pixelBuffer))</span><br><span class="line">  <span class="keyword">let</span> sy = <span class="type">CGFloat</span>(<span class="type">ModelInputHeight</span>) / <span class="type">CGFloat</span>(<span class="type">CVPixelBufferGetWidth</span>(pixelBuffer))</span><br><span class="line">  <span class="keyword">let</span> scaleTransform = <span class="type">CGAffineTransform</span>(scaleX: sx, y: sy)</span><br><span class="line">  <span class="keyword">let</span> scaledImage = rotatedImage.transformed(by: scaleTransform)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// render : image into a pixel buffer.</span></span><br><span class="line">  ciContext.render(scaledImage, to: resizedPixelBuffer)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Model Predict</span></span><br><span class="line">  predict(image: resizedPixelBuffer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 가공된 이미지를 <code>model.prediction</code> 함수에 전달합니다. <code>output._13</code>은 CoreML Tools를 이용한 mlmodel 변환시 입력한 <code>output_names=[&#39;13&#39;]</code> 입니다.</p><figure class="highlight swift"><figcaption><span>YOLO model predict</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> model = light_tiny_model()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">predict</span><span class="params">(image: CVPixelBuffer)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">Prediction</span>]? &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> output = <span class="keyword">try</span>? model.prediction(image: image) &#123;</span><br><span class="line">    <span class="keyword">return</span> computeBoundingBoxes(features: output.<span class="number">_13</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>output.grid</code>는 각 grid당 <code>13 x 13 x 30</code> 크기의 <a href="https://developer.apple.com/documentation/coreml/mlmultiarray" target="_blank" rel="external nofollow noopener noreferrer">MLMultiArray</a> 타입의 결과로 <code>computeBoundingBoxes()</code> 함수로 전달하여 결과에 대한 후처리를 진행합니다. </p><hr><h2 id="Vision-Framework"><a href="#Vision-Framework" class="headerlink" title="Vision Framework"></a>Vision Framework</h2><p><a href="https://developer.apple.com/documentation/vision" target="_blank" rel="external nofollow noopener noreferrer">Vision</a> Framework를 이용하여 Model에 맞는 input 이미지를 전처리할 수 있습니다.</p><figure class="highlight swift"><figcaption><span>Vision Framework 세팅</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request: <span class="type">VNCoreMLRequest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 초기 세팅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setUpVision</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> visionModel = <span class="keyword">try</span>? <span class="type">VNCoreMLModel</span>(<span class="keyword">for</span>: yolo.model.model) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: could not create Vision model"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  request = <span class="type">VNCoreMLRequest</span>(model: visionModel, completionHandler: visionRequestDidComplete)</span><br><span class="line">  request.imageCropAndScaleOption = .scaleFill</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 완료시 호출 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visionRequestDidComplete</span><span class="params">(request: VNRequest, error: Error?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> observations = request.results <span class="keyword">as</span>? [<span class="type">VNCoreMLFeatureValueObservation</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 13 x 13 x 30에 해당하는 결과 찾기</span></span><br><span class="line">  <span class="keyword">if</span> observationsIndex == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i, observation) <span class="keyword">in</span> observations.enumerated() &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> feature = observation.featureValue.multiArrayValue <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">      <span class="keyword">if</span> feature.<span class="built_in">count</span> == featureCount &#123;</span><br><span class="line">        <span class="keyword">self</span>.observationsIndex = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> observationsIndex != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> output = observations[observationsIndex!].featureValue.multiArrayValue &#123;</span><br><span class="line">      computeBoundingBoxes(features: output)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>Vision framework를 이용한 이미지 전처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResizedPixelBufferByVision</span><span class="params">(pixelBuffer: CVPixelBuffer, request: VNCoreMLRequest)</span></span> &#123;</span><br><span class="line">  <span class="comment">// orientation 옵션에 .right를 주어 오른쪽으로 회전</span></span><br><span class="line">  <span class="keyword">let</span> handler = <span class="type">VNImageRequestHandler</span>(cvPixelBuffer: pixelBuffer, orientation: .<span class="keyword">right</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 수행 완료시 visionRequestDidComplete()를 호출</span></span><br><span class="line">  handler.perform([request])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>output</code>은 각 grid당 <code>13 x 13 x 30</code> 크기의 <a href="https://developer.apple.com/documentation/coreml/mlmultiarray" target="_blank" rel="external nofollow noopener noreferrer">MLMultiArray</a> 타입의 결과로 <code>computeBoundingBoxes()</code> 함수로 전달하여 결과에 대한 후처리를 진행합니다.</p><hr><h1 id="Model-Output-Postprocessing"><a href="#Model-Output-Postprocessing" class="headerlink" title="# Model Output Postprocessing"></a># Model Output Postprocessing</h1><p>Model은 각 이미지당 <code>13 x 13 x 30</code> 텐서를 반환합니다.</p><blockquote><p>N x N x (C + 5) x B)</p></blockquote><ul><li>N x N : Grid</li><li>C : 학습한 Object 수(Classes)</li><li>5 : 탐지한 Object의 Bounding Box 정보(x, y, w, h, confidence)</li><li>B : Grid cell당 박스 수</li></ul><p>전체 Bounding Box를 그대로 화면에 나타낸다면 대략 다음과 같은 결과가 나옵니다.</p><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/71397817-f73ee980-2661-11ea-9eb5-07123bd0d588.png" target="_blank" rel="external nofollow noopener noreferrer" title="YOLO output을 나타낸 이미지<br>출처 - <a href=https://machinethink.net/blog/object-detection-with-yolo/>https://machinethink.net</a>" data-caption="YOLO output을 나타낸 이미지<br>출처 - <a href=https://machinethink.net/blog/object-detection-with-yolo/>https://machinethink.net</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/71397817-f73ee980-2661-11ea-9eb5-07123bd0d588.png" style="width:300px;" alt="YOLO output을 나타낸 이미지<br>출처 - <a href=https://machinethink.net/blog/object-detection-with-yolo/>https://machinethink.net</a>"></a><span class="caption">YOLO output을 나타낸 이미지<br>출처 - <a href="https://machinethink.net/blog/object-detection-with-yolo/" rel="external nofollow noopener noreferrer" target="_blank">https://machinethink.net</a></span></div><p>무수히 많은 박스 중에서 실제 물체의 위치에 해당하는 결과만 필터링하여 아래와 같이 깔끔한 Bounding Box를 그리기 위해선 output에 대한 후처리가 필요합니다.</p><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/71397849-0de54080-2662-11ea-924f-155b89afab87.png" target="_blank" rel="external nofollow noopener noreferrer" title="YOLO output을 필터링하여 나타낸 이미지<br>출처 - <a href=https://machinethink.net/blog/object-detection-with-yolo/>https://machinethink.net</a>" data-caption="YOLO output을 필터링하여 나타낸 이미지<br>출처 - <a href=https://machinethink.net/blog/object-detection-with-yolo/>https://machinethink.net</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/71397849-0de54080-2662-11ea-924f-155b89afab87.png" style="width:300px;" alt="YOLO output을 필터링하여 나타낸 이미지<br>출처 - <a href=https://machinethink.net/blog/object-detection-with-yolo/>https://machinethink.net</a>"></a><span class="caption">YOLO output을 필터링하여 나타낸 이미지<br>출처 - <a href="https://machinethink.net/blog/object-detection-with-yolo/" rel="external nofollow noopener noreferrer" target="_blank">https://machinethink.net</a></span></div><blockquote><p>✔︎ 진행 순서</p></blockquote><ul><li>Compute Bounding Boxes</li><li>Bounding Box 그리기</li></ul><hr><h2 id="Compute-Bounding-Boxes"><a href="#Compute-Bounding-Boxes" class="headerlink" title="Compute Bounding Boxes"></a>Compute Bounding Boxes</h2><blockquote><p><a href="https://curt-park.github.io/2017-03-26/yolo/" target="_blank" rel="external nofollow noopener noreferrer">[분석] YOLO</a> 포스팅에서는 YOLO Model의 ouput을 다음과 같이 설명합니다.</p></blockquote><ul><li>Input image를 N X N grid로 나눕니다.</li><li>각각의 grid cell은 B개의 Bounding Box와 각 Bounding Box에 대한 confidence score를 갖습니다.<br>(만약 cell에 object가 존재하지 않는다면 confidence score는 0)</li><li>각각의 grid cell은 C개의 conditional class probability를 갖습니다.</li><li>각각의 Bounding Box는 x, y, w, h, confidence로 구성됩니다.<br>(x, y): Bounding Box의 중심점을 의미하며, grid cell의 범위에 대한 상대값이 입력<br>(w, h): 전체 이미지의 width, height에 대한 상대값이 입력<ul><li>예1: 만약 x가 grid cell의 가장 왼쪽에 있다면 x = 0, y가 grid cell의 중간에 있다면 y = 0.5</li><li>예2: bbox의 width가 이미지 width의 절반이라면 w = 0.5</li></ul></li></ul><p>위와 같은 output을 아래 <code>computeBoundingBoxes()</code> 함수를 이용하여 정리해줍니다.</p><figure class="highlight swift"><figcaption><span>Bounding Box 필터링</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anchors: [<span class="type">Float</span>] = [<span class="number">1.08</span>, <span class="number">1.19</span>, <span class="number">3.42</span>, <span class="number">4.41</span>, <span class="number">6.63</span>, <span class="number">11.38</span>, <span class="number">9.42</span>, <span class="number">5.11</span>, <span class="number">16.62</span>, <span class="number">10.52</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeBoundingBoxes</span><span class="params">(features: MLMultiArray, featureCount: Int)</span></span> -&gt; [<span class="type">Prediction</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> predictions = [<span class="type">Prediction</span>]()</span><br><span class="line">  <span class="keyword">let</span> blockSize: <span class="type">Float</span> = <span class="number">32</span></span><br><span class="line">  <span class="keyword">let</span> gridHeight = <span class="number">13</span></span><br><span class="line">  <span class="keyword">let</span> gridWidth = <span class="number">13</span></span><br><span class="line">  <span class="keyword">let</span> boxesPerCell = <span class="number">3</span></span><br><span class="line">  <span class="keyword">let</span> numClasses = labels.<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> featurePointer = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Double</span>&gt;(<span class="type">OpaquePointer</span>(features.dataPointer))</span><br><span class="line">  <span class="keyword">let</span> channelStride = features.strides[<span class="number">0</span>].intValue</span><br><span class="line">  <span class="keyword">let</span> yStride = features.strides[<span class="number">1</span>].intValue</span><br><span class="line">  <span class="keyword">let</span> xStride = features.strides[<span class="number">2</span>].intValue</span><br><span class="line"></span><br><span class="line">  @inline(__always) <span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(<span class="number">_</span> channel: Int, <span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> channel*channelStride + y*yStride + x*xStride</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> cy <span class="keyword">in</span> <span class="number">0</span>..&lt; gridHeight &#123;</span><br><span class="line">    <span class="keyword">for</span> cx <span class="keyword">in</span> <span class="number">0</span>..&lt; gridWidth &#123;</span><br><span class="line">      <span class="keyword">for</span> b <span class="keyword">in</span> <span class="number">0</span>..&lt; boxesPerCell &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> channel = b*(numClasses + <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// Grid 상의 x, y 위치</span></span><br><span class="line">        <span class="keyword">let</span> tx = <span class="type">Float</span>(featurePointer[offset(channel    , cx, cy)])</span><br><span class="line">        <span class="keyword">let</span> ty = <span class="type">Float</span>(featurePointer[offset(channel + <span class="number">1</span>, cx, cy)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tw = <span class="type">Float</span>(featurePointer[offset(channel + <span class="number">2</span>, cx, cy)])</span><br><span class="line">        <span class="keyword">let</span> th = <span class="type">Float</span>(featurePointer[offset(channel + <span class="number">3</span>, cx, cy)])</span><br><span class="line">        <span class="keyword">let</span> tc = <span class="type">Float</span>(featurePointer[offset(channel + <span class="number">4</span>, cx, cy)])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 박스의 중심좌표 (x, y)</span></span><br><span class="line">        <span class="keyword">let</span> x = (<span class="type">Float</span>(cx) + sigmoid(tx)) * blockSize</span><br><span class="line">        <span class="keyword">let</span> y = (<span class="type">Float</span>(cy) + sigmoid(ty)) * blockSize</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 박스의 with, height</span></span><br><span class="line">        <span class="keyword">let</span> w = exp(tw) * anchors[<span class="number">2</span>*b    ] * blockSize</span><br><span class="line">        <span class="keyword">let</span> h = exp(th) * anchors[<span class="number">2</span>*b + <span class="number">1</span>] * blockSize</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 박스안에 물체가 있을 확률</span></span><br><span class="line">        <span class="keyword">let</span> confidence = sigmoid(tc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> classes = [<span class="type">Float</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: numClasses)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="number">0</span>..&lt; numClasses &#123;</span><br><span class="line">          classes[<span class="built_in">c</span>] = <span class="type">Float</span>(featurePointer[offset(channel + <span class="number">5</span> + <span class="built_in">c</span>, cx, cy)])</span><br><span class="line">        &#125;</span><br><span class="line">        classes = softmax(classes)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 박스안에 있는 class</span></span><br><span class="line">        <span class="keyword">let</span> (detectedClass, bestClassScore) = classes.argmax()</span><br><span class="line">        <span class="keyword">let</span> confidenceInClass = bestClassScore * confidence</span><br><span class="line">        <span class="keyword">if</span> confidenceInClass &gt; confidenceThreshold &#123;</span><br><span class="line">          <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="type">CGFloat</span>(x - w/<span class="number">2</span>), y: <span class="type">CGFloat</span>(y - h/<span class="number">2</span>),</span><br><span class="line">                            width: <span class="type">CGFloat</span>(w), height: <span class="type">CGFloat</span>(h))</span><br><span class="line">          <span class="keyword">let</span> prediction = <span class="type">Prediction</span>(classIndex: detectedClass,</span><br><span class="line">                                      score: confidenceInClass,</span><br><span class="line">                                      rect: rect)</span><br><span class="line">          predictions.append(prediction)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 중첩되는 Bounding Box 제거</span></span><br><span class="line"><span class="comment">   * - boxes: Bounding Box와 score 배열</span></span><br><span class="line"><span class="comment">   * - limit: 선택가능한 최대 박스 개수</span></span><br><span class="line"><span class="comment">   * - threshold: 중첩 박스여부 판단 기준</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> nonMaxSuppression(boxes: predictions,</span><br><span class="line">                           limit: <span class="number">10</span>,</span><br><span class="line">                           threshold: <span class="number">0.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>computeBoundingBoxes에 대한 자세한 설명은 <a href="https://machinethink.net/blog/object-detection-with-yolo/" target="_blank" rel="external nofollow noopener noreferrer">Real-time object detection with YOLO</a>를 참고하시기 바랍니다.</p></blockquote><p><code>computeBoundingBoxes()</code> 함수는 불필요한 박스를 제외하고 신뢰도 있는 최종 <code>Prediction</code> 배열을 반환합니다.</p><figure class="highlight swift"><figcaption><span>Prediction에는 Bounding Box, 박스안에 존재하는 class 그리고 score가 들어있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prediction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> classIndex: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> score: <span class="type">Float</span></span><br><span class="line">  <span class="keyword">let</span> rect: <span class="type">CGRect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/hollance/YOLO-CoreML-MPSNNGraph/tree/master/TinyYOLO-CoreML" target="_blank" rel="external nofollow noopener noreferrer">TinyYOLO-CoreML</a>를 참조하여 구현하였기에 전체 코드는 해당 프로젝트를 참고하시기 바랍니다.</p></blockquote><hr><h2 id="Bounding-Box-그리기"><a href="#Bounding-Box-그리기" class="headerlink" title="Bounding Box 그리기"></a>Bounding Box 그리기</h2><p>처음 <code>ARSessionDelegate</code>에서 얻은 이미지는 <code>16:9</code>가 아닌 <code>16:12</code>의 비율을 가지고 있고, 해당 이미지를 <code>416 x 416</code>으로 변환하여 모델에 입력하였습니다.</p><figure class="highlight swift"><figcaption><span>ARSessionDelegate에서 rotate right하여 얻은 이미지 사이즈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CVPixelBuffer</span> <span class="type">Height</span> : <span class="number">1920</span></span><br><span class="line"><span class="type">CVPixelBuffer</span> <span class="type">Width</span>  : <span class="number">1440</span></span><br></pre></td></tr></table></figure><p>따라서 Model이 반환하는 Bounding Box를 실제 모바일 화면에 그리기 위해 <a href="https://developer.apple.com/documentation/coregraphics/cgrect" target="_blank" rel="external nofollow noopener noreferrer">CGRect</a> 구조체의 x, y, width, height를 <code>getScreenRect()</code> 함수를 구현하여 스케일을 조정하였습니다.<br><br></p><div class="figure center" style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/71437302-62f18700-2734-11ea-8f6a-874d2a062e3e.png" target="_blank" rel="external nofollow noopener noreferrer" title="CGRect 구조" data-caption="CGRect 구조" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/71437302-62f18700-2734-11ea-8f6a-874d2a062e3e.png" style="width:350px;" alt="CGRect 구조"></a><span class="caption">CGRect 구조</span></div><figure class="highlight swift"><figcaption><span>Bounding Box Rescale</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">ModelInputWidth</span> = <span class="number">416</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">ModelInputHeight</span> = <span class="number">416</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getScreenRect</span><span class="params">(prediction: Prediction, screenWidth: CGFloat, screenHeight: CGFloat)</span></span> -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = prediction.rect</span><br><span class="line">  <span class="keyword">let</span> scaleX = screenWidth / <span class="type">CGFloat</span>(<span class="type">ModelInputWidth</span>)</span><br><span class="line">  <span class="keyword">let</span> scaleY = screenHeight / <span class="type">CGFloat</span>(<span class="type">ModelInputHeight</span>)</span><br><span class="line">  <span class="keyword">let</span> x1 = rect.origin.x</span><br><span class="line">  <span class="keyword">let</span> x2 = rect.origin.x + rect.size.width</span><br><span class="line">  <span class="keyword">let</span> xc = screenWidth/<span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> wx1 = xc - x1</span><br><span class="line">  <span class="keyword">let</span> wx2 = xc - x2</span><br><span class="line">  <span class="keyword">let</span> swx1 = wx1 * <span class="number">12</span> / <span class="number">9</span></span><br><span class="line">  <span class="keyword">let</span> swx2 = wx2 * <span class="number">12</span> / <span class="number">9</span></span><br><span class="line">  </span><br><span class="line">  rect.origin.x = xc - swx1</span><br><span class="line">  rect.size.width = <span class="built_in">abs</span>(swx1 - swx2)</span><br><span class="line">  rect.origin.x *= scaleX</span><br><span class="line">  rect.origin.y *= scaleY</span><br><span class="line">  rect.size.width *= scaleX</span><br><span class="line">  rect.size.height *= scaleY</span><br><span class="line">  <span class="keyword">return</span> rect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 최종적으로 후처리된 결과를 <a href="https://developer.apple.com/documentation/uikit/uibezierpath" target="_blank" rel="external nofollow noopener noreferrer">UIBezierPath</a>를 이용하여 화면에 실시간으로 나타내었습니다.</p><figure class="highlight swift"><figcaption><span>Draw Bounding Box</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(frame: CGRect, label: String, color: UIColor)</span></span> &#123;</span><br><span class="line">  <span class="type">CATransaction</span>.setDisableActions(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(rect: frame)</span><br><span class="line">  shapeLayer.path = path.cgPath</span><br><span class="line">  shapeLayer.strokeColor = color.cgColor</span><br><span class="line">  shapeLayer.isHidden = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  textLayer.string = label</span><br><span class="line">  textLayer.backgroundColor = color.cgColor</span><br><span class="line">  textLayer.isHidden = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> attributes = [</span><br><span class="line">    <span class="type">NSAttributedString</span>.<span class="type">Key</span>.font: textLayer.font <span class="keyword">as</span> <span class="type">Any</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> textRect = label.boundingRect(with: <span class="type">CGSize</span>(width: <span class="number">400</span>, height: <span class="number">100</span>),</span><br><span class="line">                                    options: .truncatesLastVisibleLine,</span><br><span class="line">                                    attributes: attributes, context: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">let</span> textSize = <span class="type">CGSize</span>(width: textRect.width + <span class="number">12</span>, height: textRect.height)</span><br><span class="line">  <span class="keyword">let</span> textOrigin = <span class="type">CGPoint</span>(x: frame.origin.x - <span class="number">2</span>, y: frame.origin.y - textSize.height)</span><br><span class="line">  textLayer.frame = <span class="type">CGRect</span>(origin: textOrigin, size: textSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="YOLO-Model을-이용한-실시간-조명탐지-구현"><a href="#YOLO-Model을-이용한-실시간-조명탐지-구현" class="headerlink" title="# YOLO Model을 이용한 실시간 조명탐지 구현"></a># YOLO Model을 이용한 실시간 조명탐지 구현</h1><blockquote><p>✔︎ 진행순서</p></blockquote><ul><li>조명의 3차원 좌표 획득</li><li>실시간 조명 설치 및 해제</li></ul><hr><h2 id="조명의-3차원-좌표-획득"><a href="#조명의-3차원-좌표-획득" class="headerlink" title="조명의 3차원 좌표 획득"></a>조명의 3차원 좌표 획득</h2><p>YOLO Model이 탐지한 Bounding Box의 중심 좌표와 ARKit의 <a href="https://developer.apple.com/documentation/arkit/arscnview/2875544-hittest" target="_blank" rel="external nofollow noopener noreferrer">hitTest()</a>를 이용하면 오브젝트의 3차원 좌표를 획득할 수 있습니다.</p><figure class="highlight swift"><figcaption><span>hitTest() 함수를 이용하여 3D 좌표 획득</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getARAnchorPosition</span><span class="params">(point: CGPoint, ResultType type: ARHitTestResult.ResultType = .featurePoint)</span></span> -&gt; <span class="type">SCNVector3?</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hitTestResults = hitTest(point, types: type)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> hitTestResult = hitTestResults.first <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> translation = hitTestResult.worldTransform.translation <span class="comment">// 3차원 좌표</span></span><br><span class="line">  <span class="keyword">let</span> x = translation.x</span><br><span class="line">  <span class="keyword">let</span> y = translation.y</span><br><span class="line">  <span class="keyword">let</span> z = translation.z</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="type">SCNVector3</span>(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="실시간-조명-설치-및-해제"><a href="#실시간-조명-설치-및-해제" class="headerlink" title="실시간 조명 설치 및 해제"></a>실시간 조명 설치 및 해제</h2><p>이번 프로젝트의 YOLO Model은 총 5개의 클래스를 학습하였습니다. 그 중 램프와 전구는 ON/OFF 상태를 구분할 수 있도록 별도의 클래스로 구분하였기에 조명의 상태를 추적할 수 있습니다.</p><div class="figure " style><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70859476-81e36280-1f57-11ea-976b-697018feb25d.png" target="_blank" rel="external nofollow noopener noreferrer" title="YOLO Model이 학습한 Class" data-caption="YOLO Model이 학습한 Class" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70859476-81e36280-1f57-11ea-976b-697018feb25d.png" alt="YOLO Model이 학습한 Class"></a><span class="caption">YOLO Model이 학습한 Class</span></div><p>매 프레임마다 Model이 현재 프레임상에 존재하는 조명의 위치와 종류를 예측하는데, Bounding Box의 중심점이 다음 연속한 3프레임의 Bounding Box속에 존재하면서 동일한 클래스를 예측하는 경우, 해당 클래스에 해당하는 조명이 실제한다고 판단하여 행동을 취하도록 구현하였습니다. 예를들어 3회 연속 ON 상태의 조명을 인식하면 해당 위치에 SCNLight를 설치하고, 반대로 OFF 상태의 조명을 인식하면 해당 마지막 Bounding Box속에 존재하는 SCNLight를 삭제하였습니다.</p><div class="nero-grid">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="YOLO 조명 on 상태 인식"><source src="/assets/videos/pj-too-real/04.install_scnlight.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">YOLO 조명 on 상태 인식</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="YOLO 조명 off 상태 인식"><source src="/assets/videos/pj-too-real/05.remove_scnlight.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">YOLO 조명 off 상태 인식</span></div></div></div><p>화면상에 노란색 구슬은 SCNLight 설치여부를 볼 수 있도록 시각화한 가상 오브젝트입니다.</p><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>처음엔 CoreML을 이용하여 YOLO Model을 올리면 끝날 줄 알았는데, Model의 input과 output에 대한 처리에 대한 부분이 생각보다 힘들었습니다. 😭</p><p>이상으로 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기 4부작을 마치도록하겠습니다. 🎉<br>긴 글 읽어주셔서 감사합니다.</p><blockquote><p>목차</p></blockquote><ul><li><a href="/2019/12/25/pj-too-real-01/">1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</a></li><li><a href="/2019/12/24/pj-too-real-02/">2부. 현실감 있는 iOS AR앱 만들기</a></li><li><a href="/2019/12/23/pj-too-real-03/">3부. Custom YOLO 모델 만들기</a></li><li>✔︎ 4부. iOS에 YOLO 모델 탑재하기</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 어플리케이션에 YOLO 모델을 탑재하는 방법에 대해 공유합니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Project" scheme="https://nero.devstory.co.kr/categories/Project/"/>
    
    
      <category term="Too Real" scheme="https://nero.devstory.co.kr/tags/Too-Real/"/>
    
  </entry>
  
  <entry>
    <title>Python Itertools</title>
    <link href="https://nero.devstory.co.kr/2019/11/09/pl-python-itertools/"/>
    <id>https://nero.devstory.co.kr/2019/11/09/pl-python-itertools/</id>
    <published>2019-11-09T09:47:24.000Z</published>
    <updated>2019-12-07T10:37:20.545Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 Python 2.7과 3.5부터 탑제된 <code>itertools</code>의 유용하고 자주 쓸만한 함수들을 익혀보도록 하겠습니다.<br><a id="more"></a></p><!-- > **1. Iterators terminating on the shortest input sequence**- [x] [1.1 accumulate](#accumulate)- [x] [1.2 compress](#compress)- [x] [1.3 dropwhile](#dropwhile)- [x] [1.4 groupby](#groupby)- [x] [1.5 takewhile](#takewhile)- [x] [1.6 zip_longest](#zip_longest)> **2. Combinatoric iterators**- [x] [2.1 product](#product)- [x] [2.2 permutations](#permutations)- [x] [2.3 combinations](#combinations)- [x] [2.4 combinations_with_replacement](#combinations_with_replacement) --><p>시작하기에 앞서 다음과 같이 <code>itertools</code> 모듈을 import하여, 이후 코드에서는 <code>it</code>라고 사용하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</span><br></pre></td></tr></table></figure><hr><h1 id="Iterators-terminating-on-the-shortest-input-sequence"><a href="#Iterators-terminating-on-the-shortest-input-sequence" class="headerlink" title="# Iterators terminating on the shortest input sequence"></a># Iterators terminating on the shortest input sequence</h1><hr><h2 id="accumulate-🔗"><a href="#accumulate-🔗" class="headerlink" title="accumulate 🔗 "></a>accumulate <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.accumulate" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="accumulate"></a></h2><blockquote><p>배열을 받아, 누적 합으로 이루어진 배열을 반환합니다.<br>(기본적으로 sum을 하나, 별도의 operator function을 인자로 줄 수 있습니다.)</p></blockquote><p>python3.8에서는 initial 인자가 추가되었습니다.</p><figure class="highlight python"><figcaption><span>python 버전 별 accumulate 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3.8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add, *, initial=None)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    total = initial</span><br><span class="line">    <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total = next(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.7 이하</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        total = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>자연수 배열 예제입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1  # 1</span></span><br><span class="line"><span class="string">3  # 1 + 2</span></span><br><span class="line"><span class="string">6  # 1 + 2 + 3</span></span><br><span class="line"><span class="string">10 # 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="string">15 # 1 + 2 + 3 + 4 + 5</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>숫자 뿐만 아니라 문자열도 연산 가능합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">ab</span></span><br><span class="line"><span class="string">abc</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">abcde</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>다른 함수를 인자로 주어 다양한 연산도 가능합니다.</p><figure class="highlight python"><figcaption><span>operator의 곱하기 합수를 주었습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator <span class="keyword">as</span> op</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], op.mul):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1   # 1</span></span><br><span class="line"><span class="string">2   # 1 * 2</span></span><br><span class="line"><span class="string">6   # 1 * 2 * 3</span></span><br><span class="line"><span class="string">24  # 1 * 2 * 3 * 4</span></span><br><span class="line"><span class="string">120 # 1 * 2 * 3 * 4 * 5</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>max 함수를 이용하여 다음과 같은 연산도 가능합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>], max):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="compress-🔗"><a href="#compress-🔗" class="headerlink" title="compress 🔗 "></a>compress <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.compress" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="compress"></a></h2><blockquote><p>문자열과 True/False 배열을 받아서, True인 인덱스의 문자열 값만 반환합니다.</p></blockquote><br><figure class="highlight python"><figcaption><span>python3.8 compress function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(data, selectors)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (d <span class="keyword">for</span> d, s <span class="keyword">in</span> zip(data, selectors) <span class="keyword">if</span> s)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>배열에서 첫 번째와 세 번째 인자만 True이므로 a와 c만 반환했습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.compress(<span class="string">'abcd'</span>, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="dropwhile-🔗"><a href="#dropwhile-🔗" class="headerlink" title="dropwhile 🔗 "></a>dropwhile <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.dropwhile" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="dropwhile"></a></h2><blockquote><p>function과 iterable을 받아서 False 처음 등장하기 전까지는 모두 버리고, 나머지를 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 dropwhile function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropwhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    iterable = iter(iterable)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>5번째 인자인 6이 나오기 전까지는 True를 반환하므로 모두 버리고 6과 4만 출력되었습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.dropwhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">5</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="takewhile-🔗"><a href="#takewhile-🔗" class="headerlink" title="takewhile 🔗 "></a>takewhile <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.takewhile" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="takewhile"></a></h2><blockquote><p><code>dropwhile</code>과 반대로 처음 False가 등장할 때까지만 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 takewhile function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>5번째 인자인 6이 나오기 전까지만 True를 반환하므로 6부터 나머지는 반환하지 않습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.takewhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">5</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="groupby-🔗"><a href="#groupby-🔗" class="headerlink" title="groupby 🔗 "></a>groupby <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="groupby"></a></h2><blockquote><p>문자열을 입력받아 연속하여 등장하는 문자열을 그룹으로 묶어서 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 groupby class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">groupby</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable, key=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x</span><br><span class="line">        self.keyfunc = key</span><br><span class="line">        self.it = iter(iterable)</span><br><span class="line">        self.tgtkey = self.currkey = self.currvalue = object()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.id = object()</span><br><span class="line">        <span class="keyword">while</span> self.currkey == self.tgtkey:</span><br><span class="line">            self.currvalue = next(self.it)    <span class="comment"># Exit on StopIteration</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br><span class="line">        self.tgtkey = self.currkey</span><br><span class="line">        <span class="keyword">return</span> (self.currkey, self._grouper(self.tgtkey, self.id))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_grouper</span><span class="params">(self, tgtkey, id)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.id <span class="keyword">is</span> id <span class="keyword">and</span> self.currkey == tgtkey:</span><br><span class="line">            <span class="keyword">yield</span> self.currvalue</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.currvalue = next(self.it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>groupby()는 각 그룹의 문자열과 해당 문자열이 반복된 리스트를 반환합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> it.groupby(<span class="string">'AAAABBBCCDAABBB'</span>):</span><br><span class="line">    print(k, list(g))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A ['A', 'A', 'A', 'A']</span></span><br><span class="line"><span class="string">B ['B', 'B', 'B']</span></span><br><span class="line"><span class="string">C ['C', 'C']</span></span><br><span class="line"><span class="string">D ['D']</span></span><br><span class="line"><span class="string">A ['A', 'A']</span></span><br><span class="line"><span class="string">B ['B', 'B', 'B']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="zip-longest-🔗"><a href="#zip-longest-🔗" class="headerlink" title="zip_longest 🔗 "></a>zip_longest <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.zip_longest" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="zip_longest"></a></h2><blockquote><p>내장함수 zip과 달리 가장 <strong>긴 인자</strong>를 기준으로 zip 연산을 합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 zip_longest function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_longest</span><span class="params">(*args, fillvalue=None)</span>:</span></span><br><span class="line">    iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> args]</span><br><span class="line">    num_active = len(iterators)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        values = []</span><br><span class="line">        <span class="keyword">for</span> i, it <span class="keyword">in</span> enumerate(iterators):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = next(it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                num_active -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                iterators[i] = repeat(fillvalue)</span><br><span class="line">                value = fillvalue</span><br><span class="line">            values.append(value)</span><br><span class="line">        <span class="keyword">yield</span> tuple(values)</span><br></pre></td></tr></table></figure><p>zip_longest를 예제에 앞서 내장함수 <code>zip</code>에 대해 알아보겠습니다.</p><blockquote><p><code>zip</code>은 길이가 <strong>짧은 인자</strong>를 기준으로 요소들을 결합한 배열을 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>'abc'가 'ㄱㄴㄷㄹㅁ' 보다 길이가 짧으므로 'abc' 기준으로 결과가 반환 된 것을 볼 수 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(zip(<span class="string">'abc'</span>, <span class="string">'ㄱㄴㄷㄹㅁ'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('a', 'ㄱ'), ('b', 'ㄴ'), ('c', 'ㄷ')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>zip_longest는 길이가 긴 'ㄱㄴㄷㄹㅁ'를 기준으로 모자란 부분은 None을 채워서 반환하는 것을 볼 수 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.zip_longest(<span class="string">'abc'</span>, <span class="string">'ㄱㄴㄷㄹㅁ'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('a', 'ㄱ'), ('b', 'ㄴ'), ('c', 'ㄷ'), (None, 'ㄹ'), (None, 'ㅁ')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h1 id="Combinatoric-iterators"><a href="#Combinatoric-iterators" class="headerlink" title="# Combinatoric iterators"></a># Combinatoric iterators</h1><hr><h2 id="product-🔗"><a href="#product-🔗" class="headerlink" title="product 🔗 "></a>product <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.product" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="product"></a></h2><blockquote><p><code>product</code>는 iterable의 곱집합을 구하는 함수입니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 product function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    result = [[]]</span><br><span class="line">    <span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">        result = [x+[y] <span class="keyword">for</span> x <span class="keyword">in</span> result <span class="keyword">for</span> y <span class="keyword">in</span> pool]</span><br><span class="line">    <span class="keyword">for</span> prod <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">yield</span> tuple(prod)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>'ABCD'와 'xy'의 곱집합인 'Ax Ay Bx By Cx Cy Dx Dy'를 반환하는 예제입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list(it.product(<span class="string">'ABCD'</span>, <span class="string">'xy'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'x'),</span></span><br><span class="line"><span class="string"> ('A', 'y'),</span></span><br><span class="line"><span class="string"> ('B', 'x'),</span></span><br><span class="line"><span class="string"> ('B', 'y'),</span></span><br><span class="line"><span class="string"> ('C', 'x'),</span></span><br><span class="line"><span class="string"> ('C', 'y'),</span></span><br><span class="line"><span class="string"> ('D', 'x'),</span></span><br><span class="line"><span class="string"> ('D', 'y')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>repeat 인자를 넣어주어 다음이 활용할 수도 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list(it.product(range(<span class="number">2</span>), repeat=<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[(0, 0, 0),</span></span><br><span class="line"><span class="string"> (0, 0, 1),</span></span><br><span class="line"><span class="string"> (0, 1, 0),</span></span><br><span class="line"><span class="string"> (0, 1, 1),</span></span><br><span class="line"><span class="string"> (1, 0, 0),</span></span><br><span class="line"><span class="string"> (1, 0, 1),</span></span><br><span class="line"><span class="string"> (1, 1, 0),</span></span><br><span class="line"><span class="string"> (1, 1, 1)]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1과 -1로된 크기가 3인 배열의 경우의 수는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br></pre></td></tr></table></figure><p>위 함수를 <code>product</code>를 이용하면 한줄로 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(it.product([<span class="number">1</span>, <span class="number">-1</span>], repeat=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="permutations-🔗"><a href="#permutations-🔗" class="headerlink" title="permutations 🔗 "></a>permutations <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="permutations"></a></h2><blockquote><p><code>순열</code>을 뜻하는 <code>permutations</code>은 n개 중에서 r개를 뽑아 만들 수 있는 순서있는 나열입니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 permutations function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(n))</span><br><span class="line">    cycles = list(range(n, n-r, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            cycles[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cycles[i] == <span class="number">0</span>:</span><br><span class="line">                indices[i:] = indices[i+<span class="number">1</span>:] + indices[i:i+<span class="number">1</span>]</span><br><span class="line">                cycles[i] = n - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = cycles[i]</span><br><span class="line">                indices[i], indices[-j] = indices[-j], indices[i]</span><br><span class="line">                <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>순열의 개수는 다음과 같이 구할 수 있습니다.</p><blockquote><p>nPr = n!/(n-r)!</p></blockquote><figure class="highlight python"><figcaption><span>두 번째 인자는 iterable에서 뽑는 개수이므로 len(iterable) 보다 클 수 없습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list(it.permutations(<span class="string">'ABCD'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'B'),</span></span><br><span class="line"><span class="string"> ('A', 'C'),</span></span><br><span class="line"><span class="string"> ('A', 'D'),</span></span><br><span class="line"><span class="string"> ('B', 'A'),</span></span><br><span class="line"><span class="string"> ('B', 'C'),</span></span><br><span class="line"><span class="string"> ('B', 'D'),</span></span><br><span class="line"><span class="string"> ('C', 'A'),</span></span><br><span class="line"><span class="string"> ('C', 'B'),</span></span><br><span class="line"><span class="string"> ('C', 'D'),</span></span><br><span class="line"><span class="string"> ('D', 'A'),</span></span><br><span class="line"><span class="string"> ('D', 'B'),</span></span><br><span class="line"><span class="string"> ('D', 'C')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>r을 생략할 경우 iterable 크기만큼 뽑아서 만들 수 있는 순열을 반환합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.permutations(range(<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="combinations-🔗"><a href="#combinations-🔗" class="headerlink" title="combinations 🔗 "></a>combinations <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.combinations" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="combinations"></a></h2><blockquote><p><code>조합</code>을 의미하는 <code>combinations</code>는 n개 중에서 r를 뽑아 만들 수 있는 집합(set)의 나열입니다. (한 번 뽑은 인자는 다시 뽑을 수 없습니다.)</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 combinations function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(r))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != i + n - r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, r):</span><br><span class="line">            indices[j] = indices[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p>조합의 개수는 다음과 같이 구할 수 있습니다.</p><blockquote><p>nCr = nPr/r! = n!/(r!*(n-r)!)</p></blockquote><figure class="highlight python"><figcaption><span>'ABCD' 네 개중에서 순서를 무시하고 2개를 조합하는 방법은 6가지(4C2) 입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.combinations(<span class="string">'ABCD'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="combinations-with-replacement-🔗"><a href="#combinations-with-replacement-🔗" class="headerlink" title="combinations_with_replacement 🔗 "></a>combinations_with_replacement <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.combinations_with_replacement" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="combinations_with_replacement"></a></h2><blockquote><p>위에서 설명한 <code>combinations</code>과 달리 한 번 뽑은 인자를 다시 뽑을 수 있는 경우의 조합입니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 combinations_with_replacement</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pool = tuple(iterable)</span><br><span class="line">n = len(pool)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> r:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">indices = [<span class="number">0</span>] * r</span><br><span class="line"><span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">        <span class="keyword">if</span> indices[i] != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices[i:] = [indices[i] + <span class="number">1</span>] * (r - i)</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>'A'를 뽑은 뒤 'A'를 또 뽑을 수 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>직접 코드로 구현하는데 상당한 시간이 걸리는 함수들을 <code>Itertools</code>를 이용하여 손쉽게 이용할 수 있습니다.<br>본 포스팅에서 설명하지 않은 함수들은 <a href="https://docs.python.org/ko/3.8/library/itertools.html#module-itertools" target="_blank" rel="external nofollow noopener noreferrer">공식문서</a>를 참고하시기 바랍니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이번 포스팅에서는 Python 2.7과 3.5부터 탑제된 &lt;code&gt;itertools&lt;/code&gt;의 유용하고 자주 쓸만한 함수들을 익혀보도록 하겠습니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Program Language" scheme="https://nero.devstory.co.kr/categories/Program-Language/"/>
    
    
      <category term="python" scheme="https://nero.devstory.co.kr/tags/python/"/>
    
      <category term="itertools" scheme="https://nero.devstory.co.kr/tags/itertools/"/>
    
  </entry>
  
</feed>
