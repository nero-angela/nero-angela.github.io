<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🐈 Nero&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nero.devstory.co.kr/"/>
  <updated>2019-12-09T15:21:08.114Z</updated>
  <id>https://nero.devstory.co.kr/</id>
  
  <author>
    <name>Nero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1부. 딥러닝을 이용하여 더욱 현실감 있는 AR 앱 만들기</title>
    <link href="https://nero.devstory.co.kr/2019/11/24/pj-too-real-01/"/>
    <id>https://nero.devstory.co.kr/2019/11/24/pj-too-real-01/</id>
    <published>2019-11-24T07:44:28.000Z</published>
    <updated>2019-12-09T15:21:08.114Z</updated>
    
    <content type="html"><![CDATA[<p>딥러닝을 이용하여 더욱 현실감 있는 AR 어플리케이션을 개발한 이야기를 공유합니다.<br><a id="more"></a></p><hr><h1 id="프로젝트-소개"><a href="#프로젝트-소개" class="headerlink" title="# 프로젝트 소개"></a># 프로젝트 소개</h1><p><strong>AR(Augmented Reality)</strong>을 이용한 다양한 어플리케이션들이 출시되고 있습니다. 그런데 AR 어플리케이션 속의 가상 오브젝트들은 여러가지 이유로 현실감이 많이 떨어져 서비스 몰입도를 낮추는 것 같습니다.</p><div class="nero-video">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="부자가 되려면 AR을 개발해라(?)<br>출처 : <a href=http://www.etoland.co.kr/plugin/mobile/board.php?bo_table=etohumor01&wr_id=1589967>http://www.etoland.co.kr/</a>"><source src="/assets/videos/pj-too-real/ar-example.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">부자가 되려면 AR을 개발해라(?)<br>출처 : <a href="http://www.etoland.co.kr/plugin/mobile/board.php?bo_table=etohumor01&wr_id=1589967" rel="external nofollow noopener noreferrer" target="_blank">http://www.etoland.co.kr/</a></span></div></div></div><p>대부분의 AR 어플리케이션에서 사용되는 3D 모델들은 아래 Apple Sample Code인 <a href="https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction" target="_blank" rel="external nofollow noopener noreferrer">Placing Objects and Handling 3D Interaction</a>에 사용된 램프 모델과 같이 고정된 그림자 이미지를 가지고 있습니다. 이러한 고정된 그림자는 보통 어떠한 상황에서도 어색하지 않을 범용적인 형태의 그림자를 가지고 있지만, 상황에 따라 주변 물체와의 이질감을 유발하는 원인 중 하나입니다.</p><div class="figure " style="width:;"><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/69901403-6d826000-13c4-11ea-9282-4b58dac120ac.png" target="_blank" rel="external nofollow noopener noreferrer" title="Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href=https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction>Placing Objects and Handling 3D Interaction</a>" data-caption="Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href=https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction>Placing Objects and Handling 3D Interaction</a>" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/69901403-6d826000-13c4-11ea-9282-4b58dac120ac.png" alt="Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href=https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction>Placing Objects and Handling 3D Interaction</a>"></a><span class="caption">Apple의 Sample Code에 사용된 램프 모델<br>출처 - <a href="https://developer.apple.com/documentation/arkit/placing_objects_and_handling_3d_interaction" rel="external nofollow noopener noreferrer" target="_blank">Placing Objects and Handling 3D Interaction</a></span></div><p>가끔 고정된 그림자 이미지가 아닌, 임의의 가상 조명을 생성하여 오브젝트에 그림자를 랜더링하는 몇몇 AR 어플리케이션들이 있었지만, 가상 조명의 위치나 밝기가 현실에 존재하는 실제 조명과 달라 오히려 오브젝트에 부조화스러운 그림자를 생성해 현실감을 떨어뜨렸습니다.</p><p>주변 물체와 다르게 랜더링 된 가상 오브젝트의 그림자가 이질감의 원인 중 하나라는 사실을 알게되었고, 따라서 현실에 있는 조명의 <strong>위치</strong>와 <strong>밝기</strong> 정보를 가상 오브젝트에 반영하여 이를 해결해 보자라는 프로젝트의 목표를 설정하였습니다.</p><blockquote><p>✔︎ 프로젝트 목표<br>현실의 조명의 위치와 밝기 정보가 반영된, 더욱 현실감 있는 AR 어플리케이션 만들어보자!</p></blockquote><!-- TODO :: before와 after 이미지 넣고 이걸 이렇게! 추가하기 --><hr><h1 id="프로젝트-결과물"><a href="#프로젝트-결과물" class="headerlink" title="# 프로젝트 결과물"></a># 프로젝트 결과물</h1><h2 id="데모-영상"><a href="#데모-영상" class="headerlink" title="데모 영상"></a>데모 영상</h2><p>백문이 불여일견이니 먼저 어플리케이션 작동 영상을 보겠습니다.</p><iframe width="100%" height="500" src="https://www.youtube.com/embed/1RMhd_r3AuQ?cc_load_policy=1&mute=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><!-- iOS 앱은 [App Store](https://apps.apple.com/kr/app/tooreal/id1473239669)에 게시해 두었습니다. --><hr><h1 id="기능-소개"><a href="#기능-소개" class="headerlink" title="# 기능 소개"></a># 기능 소개</h1><p>전체적인 어플리케이션은 다음과 같이 여섯 단계로 서비스 로직이 진행됩니다.</p><blockquote><p>✔︎ ARKit &amp; SceneKit을 이용한 AR 개발</p></blockquote><ul><li>평면 탐지(Plane Detection)</li><li>설치가능한 가상 오브젝트 추천</li><li>가상 오브젝트 설치 및 인터랙션</li></ul><blockquote><p>✔︎ 딥러닝을 이용한 조명 인식</p></blockquote><ul><li>Google Vision API 방식</li><li>YOLO v3 방식</li></ul><hr><h2 id="ARKit-amp-SceneKit을-이용한-AR-개발"><a href="#ARKit-amp-SceneKit을-이용한-AR-개발" class="headerlink" title="ARKit &amp; SceneKit을 이용한 AR 개발"></a>ARKit &amp; SceneKit을 이용한 AR 개발</h2><div class="nero-video">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="1. 평면 탐지(Plane Detection)"><source src="/assets/videos/pj-too-real/01.plane_detection.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">1. 평면 탐지(Plane Detection)</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="2. 설치가능한 가상 오브젝트 추천"><source src="/assets/videos/pj-too-real/02.object_recommendation.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">2. 설치가능한 가상 오브젝트 추천</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="3. 가상 오브젝트 설치 및 인터랙션"><source src="/assets/videos/pj-too-real/03.install_object.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">3. 가상 오브젝트 설치 및 인터랙션</span></div></div></div><p>어플리케이션이 현실 공간을 인식하여 벽면이나 바닥을 인식합니다. 공간이 인식되면 현재 바라보고 있는 장소에 설치 가능한 가구를 목록을 보여주고, 원하는 가구를 선택하여 설치할 수 있습니다. 또한 설치된 가구를 원하는 장소로 이동하거나 회전하는 등의 기본적인 인터랙션이 가능합니다.</p><hr><h2 id="딥러닝을-이용한-조명-인식"><a href="#딥러닝을-이용한-조명-인식" class="headerlink" title="딥러닝을 이용한 조명 인식"></a>딥러닝을 이용한 조명 인식</h2><p>본 어플리케이션에서는 두 가지 조명 인식 방식을 구현하였습니다. 하나는 <a href="https://cloud.google.com/vision" target="_blank" rel="external nofollow noopener noreferrer">Google Vision API</a>를 이용한 방법이고, 다른 방법은 <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="external nofollow noopener noreferrer">YOLO v3</a>라는 딥러닝 모델을 이용한 방법으로 다음과 같은 특징을 가지고있습니다.</p><br><table><thead><tr><th>✔︎ Google Vision API 방식</th><th>✔︎ YOLO v3 방식</th></tr></thead><tbody><tr><td>• 네트워크 통신 필요</td><td>• 네트워크 통신 불필요</td></tr><tr><td>• 실시간 조명 추적 불가능</td><td>• 실시간 조명 추적 가능</td></tr><tr><td>• 조명의 정확한 좌표를 얻을 수 없음</td><td>• 조명의 2차원 좌표 획득 가능</td></tr><tr><td>• 조명의 온오프 상태를 알 수 없음</td><td>• 조명의 온오프 상태 구분가능</td></tr><tr><td>• 범용적인 조명 인식이 가능</td><td>• 학습된 5개의 조명만 인식가능</td></tr></tbody></table><hr><h3 id="1-Google-Vision-API-방식"><a href="#1-Google-Vision-API-방식" class="headerlink" title="1. Google Vision API 방식"></a>1. Google Vision API 방식</h3><div class="nero-video">  <div>    <div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="Google Vision API를 이용한 가상조명 설치"><source src="/assets/videos/pj-too-real/07.install_scnlight_by_google_vision_api.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">Google Vision API를 이용한 가상조명 설치</span></div>  </div></div><p><code>Google Vision API</code>를 이용한 방식은 사용자가 조명을 바라보고 인식 버튼을 누르면 이미지를 Google Vision API 서버로 전달하여 조명 존재여부를 요청하고, 이미지 중앙좌표의 3차원 좌표를 <a href="https://developer.apple.com/documentation/arkit/arframe/2875718-hittest" target="_blank" rel="external nofollow noopener noreferrer">hitTest</a> 메소드를 통하여 획득합니다. 그리고 <code>Google Vision API</code>에서 조명이 존재한다고 반환하는 경우, 앞서 얻은 3차원 좌표에 가상 조명을 설치하는 방식입니다.</p><p>이 방법의 경우 조명의 실제 3차원 좌표가 아닌 곳에 가상 조명이 설치된 가능성이 있고, 실시간으로 조명을 인식하는 것이 아니라 사용자가 인식하고자 하는 조명 개수만큼 인식 버튼을 눌러야한다는 단점이 있습니다. 그럼에도 불구하고 Google에서 학습한 방대한 모델을 이용하기 때문에 범용적인 조명을 인식할 수 있다는 장점을 가지고 있습니다.</p><hr><h3 id="2-YOLO-v3-방식"><a href="#2-YOLO-v3-방식" class="headerlink" title="2. YOLO v3 방식"></a>2. YOLO v3 방식</h3><div class="nero-video">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="YOLO v3 조명 on 상태 인식"><source src="/assets/videos/pj-too-real/04.install_scnlight.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">YOLO v3 조명 on 상태 인식</span></div></div>  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="YOLO v3 조명 off 상태 인식"><source src="/assets/videos/pj-too-real/05.remove_scnlight.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">YOLO v3 조명 off 상태 인식</span></div></div></div><p>이 방식은 Realtime Object Detection 모델 중 하나인 <a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="external nofollow noopener noreferrer">YOLO v3</a> 모델을 이용한 방식입니다. <code>YOLO v3</code> 모델은, 해당 이미지 안에 존재하는 조명의 온오프 상태, 종류, 신뢰도(confidence) 그리고 바운딩 박스(2차원 박스의 대각선 두 점의 좌표)를 반환합니다. 매프레임마다 바운딩 박스 좌표를 <a href="https://developer.apple.com/documentation/arkit/arframe/2875718-hittest" target="_blank" rel="external nofollow noopener noreferrer">hitTest</a> 메소드에 입력하여 조명의 3차원 좌표를 계산하고, 조명의 상태에 따라 경우 해당 좌표에 가상 조명을 추가하거나 삭제합니다.</p><p>모바일에 탑재한 <code>YOLO v3</code> 딥러닝 모델을 이용하기 때문에 네트워크 통신이 필요하지 않으며, 실시간으로 조명의 상태 및 좌표를 인식할 수 있다는 장점을 가지고 있습니다. 하지만 학습된 조명만 인식이 가능하다는 단점을 가지고 있습니다.<br><br></p><hr><h3 id="조명인식-결과"><a href="#조명인식-결과" class="headerlink" title="조명인식 결과"></a>조명인식 결과</h3><p>현실 조명에 대한 정보가 가상 오브젝트에 반영되었으므로, 아래 영상과 같이 오브젝트의 그림자가 조명과의 상대적 위치에 따라 현실감 있게 랜더링 되는 것을 보실 수 있습니다.<br><br></p><div class="nero-video">  <div><div class="figure " style><video class="fig-video" autoplay playsinline loop muted controls alt="그림자가 조명을 중심으로 랜더링 됩니다."><source src="/assets/videos/pj-too-real/06.shadow_rendering_and_object_interaction.mp4" type="video/mp4"><p>Your browser doesn't support HTML5 Video :/</p></video><span class="caption">그림자가 조명을 중심으로 랜더링 됩니다.</span></div>  </div></div><p>그 뿐만 아니라 카메라를 통해 들어오는 밝기(lm)과 색 온도(Kelvin)를 매프레임마다 가상 조명에 실시간으로 반영해주고 있기 때문에 가상 오브젝트가 주변과 유사한 텍스쳐로 표현되어 더욱 현실감을 높여줍니다.<br><br></p><div class="figure " style="width:;"><a class="fancybox" href="https://user-images.githubusercontent.com/26322627/70371587-496cd480-1918-11ea-839e-93f5f3402969.png" target="_blank" rel="external nofollow noopener noreferrer" title="에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)" data-caption="에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)" data-fancybox="default style=" visible: hidden;"><img class="fig-img" src="https://user-images.githubusercontent.com/26322627/70371587-496cd480-1918-11ea-839e-93f5f3402969.png" alt="에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)"></a><span class="caption">에디슨 전구의 따뜻한 색 온도가 반영되어 오브젝트를 더욱 현실감 있게 표현해줍니다.<br>- 왼쪽 : 조명인식 전(前) / 오른쪽 : 조명인식 후(後)</span></div><p>현실 조명의 위치와 밝기 그리고 색 온도 정보를 그대로 가상 조명으로 재현하여 <u>더욱 현실감 있는 AR 어플리케이션 구현</u>이라는 목표를 달성하였습니다. 🎉</p><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>예전부터 딥러닝 모델을 모바일에 올려보고 싶었는데, 이번에 모두 해볼 수 있어 너무 재미있게 개발 할 수 있었습니다. 전체적인 어플리케이션의 소개는 여기서 마치도록 하고 다음 포스팅에서는 개발 과정에 대해 집중적으로 공유 하겠습니다.</p><!-- CSS --><style type="text/css">  .nero-video {    display: flex;    flex-direction: row;    flex-wrap: wrap;    justify-content: space-around;    align-content: space-around;  }  .nero-video>div {    max-width: 250px;    margin-bottom: 16px;  }  @media (min-width: 320px) and (max-width: 480px) {    .nero-video>div {      max-width: none;      width: 100%;    }  }</style>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;딥러닝을 이용하여 더욱 현실감 있는 AR 어플리케이션을 개발한 이야기를 공유합니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Project" scheme="https://nero.devstory.co.kr/categories/Project/"/>
    
    
      <category term="iOS" scheme="https://nero.devstory.co.kr/tags/iOS/"/>
    
      <category term="Object Detection" scheme="https://nero.devstory.co.kr/tags/Object-Detection/"/>
    
      <category term="Deep Learning" scheme="https://nero.devstory.co.kr/tags/Deep-Learning/"/>
    
      <category term="YOLO v3" scheme="https://nero.devstory.co.kr/tags/YOLO-v3/"/>
    
      <category term="AR" scheme="https://nero.devstory.co.kr/tags/AR/"/>
    
  </entry>
  
  <entry>
    <title>Python Itertools</title>
    <link href="https://nero.devstory.co.kr/2019/11/09/pl-python-itertools/"/>
    <id>https://nero.devstory.co.kr/2019/11/09/pl-python-itertools/</id>
    <published>2019-11-09T09:47:24.000Z</published>
    <updated>2019-12-07T10:37:20.545Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 Python 2.7과 3.5부터 탑제된 <code>itertools</code>의 유용하고 자주 쓸만한 함수들을 익혀보도록 하겠습니다.<br><a id="more"></a></p><!-- > **1. Iterators terminating on the shortest input sequence**- [x] [1.1 accumulate](#accumulate)- [x] [1.2 compress](#compress)- [x] [1.3 dropwhile](#dropwhile)- [x] [1.4 groupby](#groupby)- [x] [1.5 takewhile](#takewhile)- [x] [1.6 zip_longest](#zip_longest)> **2. Combinatoric iterators**- [x] [2.1 product](#product)- [x] [2.2 permutations](#permutations)- [x] [2.3 combinations](#combinations)- [x] [2.4 combinations_with_replacement](#combinations_with_replacement) --><p>시작하기에 앞서 다음과 같이 <code>itertools</code> 모듈을 import하여, 이후 코드에서는 <code>it</code>라고 사용하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</span><br></pre></td></tr></table></figure><hr><h1 id="Iterators-terminating-on-the-shortest-input-sequence"><a href="#Iterators-terminating-on-the-shortest-input-sequence" class="headerlink" title="# Iterators terminating on the shortest input sequence"></a># Iterators terminating on the shortest input sequence</h1><hr><h2 id="accumulate-🔗"><a href="#accumulate-🔗" class="headerlink" title="accumulate 🔗 "></a>accumulate <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.accumulate" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="accumulate"></a></h2><blockquote><p>배열을 받아, 누적 합으로 이루어진 배열을 반환합니다.<br>(기본적으로 sum을 하나, 별도의 operator function을 인자로 줄 수 있습니다.)</p></blockquote><p>python3.8에서는 initial 인자가 추가되었습니다.</p><figure class="highlight python"><figcaption><span>python 버전 별 accumulate 함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3.8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add, *, initial=None)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    total = initial</span><br><span class="line">    <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total = next(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3.7 이하</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        total = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>자연수 배열 예제입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1  # 1</span></span><br><span class="line"><span class="string">3  # 1 + 2</span></span><br><span class="line"><span class="string">6  # 1 + 2 + 3</span></span><br><span class="line"><span class="string">10 # 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="string">15 # 1 + 2 + 3 + 4 + 5</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>숫자 뿐만 아니라 문자열도 연산 가능합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">ab</span></span><br><span class="line"><span class="string">abc</span></span><br><span class="line"><span class="string">abcd</span></span><br><span class="line"><span class="string">abcde</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>다른 함수를 인자로 주어 다양한 연산도 가능합니다.</p><figure class="highlight python"><figcaption><span>operator의 곱하기 합수를 주었습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator <span class="keyword">as</span> op</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], op.mul):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1   # 1</span></span><br><span class="line"><span class="string">2   # 1 * 2</span></span><br><span class="line"><span class="string">6   # 1 * 2 * 3</span></span><br><span class="line"><span class="string">24  # 1 * 2 * 3 * 4</span></span><br><span class="line"><span class="string">120 # 1 * 2 * 3 * 4 * 5</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>max 함수를 이용하여 다음과 같은 연산도 가능합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.accumulate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>], max):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="compress-🔗"><a href="#compress-🔗" class="headerlink" title="compress 🔗 "></a>compress <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.compress" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="compress"></a></h2><blockquote><p>문자열과 True/False 배열을 받아서, True인 인덱스의 문자열 값만 반환합니다.</p></blockquote><br><figure class="highlight python"><figcaption><span>python3.8 compress function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(data, selectors)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (d <span class="keyword">for</span> d, s <span class="keyword">in</span> zip(data, selectors) <span class="keyword">if</span> s)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>배열에서 첫 번째와 세 번째 인자만 True이므로 a와 c만 반환했습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.compress(<span class="string">'abcd'</span>, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="dropwhile-🔗"><a href="#dropwhile-🔗" class="headerlink" title="dropwhile 🔗 "></a>dropwhile <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.dropwhile" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="dropwhile"></a></h2><blockquote><p>function과 iterable을 받아서 False 처음 등장하기 전까지는 모두 버리고, 나머지를 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 dropwhile function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropwhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    iterable = iter(iterable)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>5번째 인자인 6이 나오기 전까지는 True를 반환하므로 모두 버리고 6과 4만 출력되었습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.dropwhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">5</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="takewhile-🔗"><a href="#takewhile-🔗" class="headerlink" title="takewhile 🔗 "></a>takewhile <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.takewhile" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="takewhile"></a></h2><blockquote><p><code>dropwhile</code>과 반대로 처음 False가 등장할 때까지만 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 takewhile function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>5번째 인자인 6이 나오기 전까지만 True를 반환하므로 6부터 나머지는 반환하지 않습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it.takewhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">5</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>]):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="groupby-🔗"><a href="#groupby-🔗" class="headerlink" title="groupby 🔗 "></a>groupby <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="groupby"></a></h2><blockquote><p>문자열을 입력받아 연속하여 등장하는 문자열을 그룹으로 묶어서 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 groupby class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">groupby</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable, key=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x</span><br><span class="line">        self.keyfunc = key</span><br><span class="line">        self.it = iter(iterable)</span><br><span class="line">        self.tgtkey = self.currkey = self.currvalue = object()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.id = object()</span><br><span class="line">        <span class="keyword">while</span> self.currkey == self.tgtkey:</span><br><span class="line">            self.currvalue = next(self.it)    <span class="comment"># Exit on StopIteration</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br><span class="line">        self.tgtkey = self.currkey</span><br><span class="line">        <span class="keyword">return</span> (self.currkey, self._grouper(self.tgtkey, self.id))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_grouper</span><span class="params">(self, tgtkey, id)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.id <span class="keyword">is</span> id <span class="keyword">and</span> self.currkey == tgtkey:</span><br><span class="line">            <span class="keyword">yield</span> self.currvalue</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.currvalue = next(self.it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>groupby()는 각 그룹의 문자열과 해당 문자열이 반복된 리스트를 반환합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> it.groupby(<span class="string">'AAAABBBCCDAABBB'</span>):</span><br><span class="line">    print(k, list(g))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A ['A', 'A', 'A', 'A']</span></span><br><span class="line"><span class="string">B ['B', 'B', 'B']</span></span><br><span class="line"><span class="string">C ['C', 'C']</span></span><br><span class="line"><span class="string">D ['D']</span></span><br><span class="line"><span class="string">A ['A', 'A']</span></span><br><span class="line"><span class="string">B ['B', 'B', 'B']</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="zip-longest-🔗"><a href="#zip-longest-🔗" class="headerlink" title="zip_longest 🔗 "></a>zip_longest <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.zip_longest" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="zip_longest"></a></h2><blockquote><p>내장함수 zip과 달리 가장 <strong>긴 인자</strong>를 기준으로 zip 연산을 합니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 zip_longest function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_longest</span><span class="params">(*args, fillvalue=None)</span>:</span></span><br><span class="line">    iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> args]</span><br><span class="line">    num_active = len(iterators)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        values = []</span><br><span class="line">        <span class="keyword">for</span> i, it <span class="keyword">in</span> enumerate(iterators):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = next(it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                num_active -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                iterators[i] = repeat(fillvalue)</span><br><span class="line">                value = fillvalue</span><br><span class="line">            values.append(value)</span><br><span class="line">        <span class="keyword">yield</span> tuple(values)</span><br></pre></td></tr></table></figure><p>zip_longest를 예제에 앞서 내장함수 <code>zip</code>에 대해 알아보겠습니다.</p><blockquote><p><code>zip</code>은 길이가 <strong>짧은 인자</strong>를 기준으로 요소들을 결합한 배열을 반환합니다.</p></blockquote><figure class="highlight python"><figcaption><span>'abc'가 'ㄱㄴㄷㄹㅁ' 보다 길이가 짧으므로 'abc' 기준으로 결과가 반환 된 것을 볼 수 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(zip(<span class="string">'abc'</span>, <span class="string">'ㄱㄴㄷㄹㅁ'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('a', 'ㄱ'), ('b', 'ㄴ'), ('c', 'ㄷ')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>zip_longest는 길이가 긴 'ㄱㄴㄷㄹㅁ'를 기준으로 모자란 부분은 None을 채워서 반환하는 것을 볼 수 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.zip_longest(<span class="string">'abc'</span>, <span class="string">'ㄱㄴㄷㄹㅁ'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('a', 'ㄱ'), ('b', 'ㄴ'), ('c', 'ㄷ'), (None, 'ㄹ'), (None, 'ㅁ')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h1 id="Combinatoric-iterators"><a href="#Combinatoric-iterators" class="headerlink" title="# Combinatoric iterators"></a># Combinatoric iterators</h1><hr><h2 id="product-🔗"><a href="#product-🔗" class="headerlink" title="product 🔗 "></a>product <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.product" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="product"></a></h2><blockquote><p><code>product</code>는 iterable의 곱집합을 구하는 함수입니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 product function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    result = [[]]</span><br><span class="line">    <span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">        result = [x+[y] <span class="keyword">for</span> x <span class="keyword">in</span> result <span class="keyword">for</span> y <span class="keyword">in</span> pool]</span><br><span class="line">    <span class="keyword">for</span> prod <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">yield</span> tuple(prod)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>'ABCD'와 'xy'의 곱집합인 'Ax Ay Bx By Cx Cy Dx Dy'를 반환하는 예제입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list(it.product(<span class="string">'ABCD'</span>, <span class="string">'xy'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'x'),</span></span><br><span class="line"><span class="string"> ('A', 'y'),</span></span><br><span class="line"><span class="string"> ('B', 'x'),</span></span><br><span class="line"><span class="string"> ('B', 'y'),</span></span><br><span class="line"><span class="string"> ('C', 'x'),</span></span><br><span class="line"><span class="string"> ('C', 'y'),</span></span><br><span class="line"><span class="string"> ('D', 'x'),</span></span><br><span class="line"><span class="string"> ('D', 'y')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>repeat 인자를 넣어주어 다음이 활용할 수도 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list(it.product(range(<span class="number">2</span>), repeat=<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[(0, 0, 0),</span></span><br><span class="line"><span class="string"> (0, 0, 1),</span></span><br><span class="line"><span class="string"> (0, 1, 0),</span></span><br><span class="line"><span class="string"> (0, 1, 1),</span></span><br><span class="line"><span class="string"> (1, 0, 0),</span></span><br><span class="line"><span class="string"> (1, 0, 1),</span></span><br><span class="line"><span class="string"> (1, 1, 0),</span></span><br><span class="line"><span class="string"> (1, 1, 1)]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1과 -1로된 크기가 3인 배열의 경우의 수는 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br></pre></td></tr></table></figure><p>위 함수를 <code>product</code>를 이용하면 한줄로 만들 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(it.product([<span class="number">1</span>, <span class="number">-1</span>], repeat=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="permutations-🔗"><a href="#permutations-🔗" class="headerlink" title="permutations 🔗 "></a>permutations <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="permutations"></a></h2><blockquote><p><code>순열</code>을 뜻하는 <code>permutations</code>은 n개 중에서 r개를 뽑아 만들 수 있는 순서있는 나열입니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 permutations function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(n))</span><br><span class="line">    cycles = list(range(n, n-r, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            cycles[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cycles[i] == <span class="number">0</span>:</span><br><span class="line">                indices[i:] = indices[i+<span class="number">1</span>:] + indices[i:i+<span class="number">1</span>]</span><br><span class="line">                cycles[i] = n - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = cycles[i]</span><br><span class="line">                indices[i], indices[-j] = indices[-j], indices[i]</span><br><span class="line">                <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>순열의 개수는 다음과 같이 구할 수 있습니다.</p><blockquote><p>nPr = n!/(n-r)!</p></blockquote><figure class="highlight python"><figcaption><span>두 번째 인자는 iterable에서 뽑는 개수이므로 len(iterable) 보다 클 수 없습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list(it.permutations(<span class="string">'ABCD'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'B'),</span></span><br><span class="line"><span class="string"> ('A', 'C'),</span></span><br><span class="line"><span class="string"> ('A', 'D'),</span></span><br><span class="line"><span class="string"> ('B', 'A'),</span></span><br><span class="line"><span class="string"> ('B', 'C'),</span></span><br><span class="line"><span class="string"> ('B', 'D'),</span></span><br><span class="line"><span class="string"> ('C', 'A'),</span></span><br><span class="line"><span class="string"> ('C', 'B'),</span></span><br><span class="line"><span class="string"> ('C', 'D'),</span></span><br><span class="line"><span class="string"> ('D', 'A'),</span></span><br><span class="line"><span class="string"> ('D', 'B'),</span></span><br><span class="line"><span class="string"> ('D', 'C')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>r을 생략할 경우 iterable 크기만큼 뽑아서 만들 수 있는 순열을 반환합니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.permutations(range(<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="combinations-🔗"><a href="#combinations-🔗" class="headerlink" title="combinations 🔗 "></a>combinations <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.combinations" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="combinations"></a></h2><blockquote><p><code>조합</code>을 의미하는 <code>combinations</code>는 n개 중에서 r를 뽑아 만들 수 있는 집합(set)의 나열입니다. (한 번 뽑은 인자는 다시 뽑을 수 없습니다.)</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 combinations function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(r))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != i + n - r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, r):</span><br><span class="line">            indices[j] = indices[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p>조합의 개수는 다음과 같이 구할 수 있습니다.</p><blockquote><p>nCr = nPr/r! = n!/(r!*(n-r)!)</p></blockquote><figure class="highlight python"><figcaption><span>'ABCD' 네 개중에서 순서를 무시하고 2개를 조합하는 방법은 6가지(4C2) 입니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.combinations(<span class="string">'ABCD'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h2 id="combinations-with-replacement-🔗"><a href="#combinations-with-replacement-🔗" class="headerlink" title="combinations_with_replacement 🔗 "></a>combinations_with_replacement <a href="https://docs.python.org/ko/3.8/library/itertools.html#itertools.combinations_with_replacement" target="_blank" rel="external nofollow noopener noreferrer">🔗</a> <a name="combinations_with_replacement"></a></h2><blockquote><p>위에서 설명한 <code>combinations</code>과 달리 한 번 뽑은 인자를 다시 뽑을 수 있는 경우의 조합입니다.</p></blockquote><figure class="highlight python"><figcaption><span>python3.8 combinations_with_replacement</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pool = tuple(iterable)</span><br><span class="line">n = len(pool)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> r:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">indices = [<span class="number">0</span>] * r</span><br><span class="line"><span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">        <span class="keyword">if</span> indices[i] != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices[i:] = [indices[i] + <span class="number">1</span>] * (r - i)</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>'A'를 뽑은 뒤 'A'를 또 뽑을 수 있습니다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list(it.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><h1 id="마무리"><a href="#마무리" class="headerlink" title="# 마무리"></a># 마무리</h1><p>직접 코드로 구현하는데 상당한 시간이 걸리는 함수들을 <code>Itertools</code>를 이용하여 손쉽게 이용할 수 있습니다.<br>본 포스팅에서 설명하지 않은 함수들은 <a href="https://docs.python.org/ko/3.8/library/itertools.html#module-itertools" target="_blank" rel="external nofollow noopener noreferrer">공식문서</a>를 참고하시기 바랍니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이번 포스팅에서는 Python 2.7과 3.5부터 탑제된 &lt;code&gt;itertools&lt;/code&gt;의 유용하고 자주 쓸만한 함수들을 익혀보도록 하겠습니다.&lt;br&gt;
    
    </summary>
    
    
      <category term="Program Language" scheme="https://nero.devstory.co.kr/categories/Program-Language/"/>
    
    
      <category term="python" scheme="https://nero.devstory.co.kr/tags/python/"/>
    
      <category term="itertools" scheme="https://nero.devstory.co.kr/tags/itertools/"/>
    
  </entry>
  
</feed>
